Processing /home/tobiasz/TODAY/a_libft.c...
#include "miniheader.h"

void	*ft_memcpy(void *dest, const void *src, size_t n)
{
	unsigned char	*dest_ptr;
	unsigned char	*src_ptr;

	dest_ptr = (unsigned char *) dest;
	src_ptr = (unsigned char *) src;
	if (dest == NULL && src == NULL)
		return (NULL);
	while (n > 0)
	{
		*dest_ptr = *src_ptr;
		if (dest != NULL)
			dest_ptr++;
		if (src != NULL)
			src_ptr++;
		n--;
	}
	return (dest);
}

char	*ft_strjoin(const char *s1, const char *s2)
{
	size_t	len1;
	size_t	len2;
	char	*str;

	if (!s1 && !s2)
		return (NULL);
	if (!s1)
		return (ft_strdup(s2));
	if (!s2)
		return (ft_strdup(s1));
	len1 = ft_strlen(s1);
	len2 = ft_strlen(s2);
	str = malloc(len1 + len2 + 1);
	if (!str)
		return (NULL);
	ft_memcpy(str, s1, len1);
	ft_memcpy(str + len1, s2, len2 + 1);
	return (str);
}

int	skip_spaces(char *input, int i)
{
	while (input[i] == ' ')
		i++;
	return (i);
}

void	*ft_calloc(size_t nmemb, size_t size)
{
	void	*ptr;

	if (nmemb != 0 && size > ULONG_MAX / nmemb)
		return (NULL);
	ptr = (void *)malloc(nmemb * size);
	if (!ptr)
		return (NULL);
	ft_bzero(ptr, (nmemb * size));
	return (ptr);
}

void	ft_bzero(void *s, size_t n)
{
	size_t				i;
	unsigned char		*b;

	i = 0;
	b = s;
	while (i < n)
	{
		*b = 0;
		b++;
		i++;
	}
}

--- End of /home/tobiasz/TODAY/a_libft.c ---

Processing /home/tobiasz/TODAY/a_libft2.c...
#include "miniheader.h"

char	*ft_strdup(const char *s)
{
	char	*str;
	int		i;
	int		l;

	if (!s)
		return (NULL);
	i = 0;
	l = ft_strlen(s);
	str = malloc(sizeof(char) * (l + 1));
	if (!str)
		return (NULL);
	while (s[i])
	{
		str[i] = s[i];
		i++;
	}
	str[i] = '\0';
	return (str);
}

int	ft_strcmp(const char *s1, const char *s2)
{
	size_t	i;

	i = 0;
	while (s1[i] && s2[i] && s1[i] == s2[i])
		i++;
	return ((unsigned char)s1[i] - (unsigned char)s2[i]);
}

int	ft_strncmp(const char *s1, const char *s2, size_t n)
{
	size_t	i;

	i = 0;
	if (n == 0)
		return (0);
	while (i < n && s1[i] && s2[i] && s1[i] == s2[i])
		i++;
	if (i == n)
		return (0);
	return ((unsigned char)s1[i] - (unsigned char)s2[i]);
}

int	is_only_white_spaces(char *input)
{
	int	i;

	i = 0;
	if (input[0] == 32)
	{
		while (input[i] == 32)
			i++;
		if (input[i] == '\0')
			return (1);
	}
	return (0);
}

--- End of /home/tobiasz/TODAY/a_libft2.c ---

Processing /home/tobiasz/TODAY/a_libft3.c...
#include "miniheader.h"

char	*ft_strndup(const char *s1, size_t n)
{
	char	*dest;
	int		s1_len;
	int		i;

	s1_len = 0;
	while (s1[s1_len] && s1_len < (int)n)
		s1_len++;
	dest = malloc(sizeof(char) * (s1_len + 1));
	if (!dest)
		return (NULL);
	i = 0;
	while (i < s1_len)
	{
		dest[i] = s1[i];
		i++;
	}
	dest[i] = '\0';
	return (dest);
}

void	*ft_memset(void *b, int c, size_t len)
{
	unsigned char	*ptr;

	ptr = (unsigned char *)b;
	while (len-- > 0)
		*(ptr++) = (unsigned char)c;
	return (b);
}

size_t	ft_strlen(const char *s)
{
	size_t	i;

	if (!s)
		return (0);
	i = 0;
	while (s[i] != '\0')
		i++;
	return (i);
}

int	ft_atoi(const char *str)
{
	int	res;
	int	negative;

	negative = 1;
	res = 0;
	while (*str && (*str == ' ' || *str == '\n' || *str == '\t'
			|| *str == '\v' || *str == '\f' || *str == '\r'))
		++str;
	if (*str == '-')
		negative = -1;
	if (*str == '-' || *str == '+')
		++str;
	while (*str && *str >= '0' && *str <= '9')
	{
		res = res * 10 + (*str - 48);
		++str;
	}
	return (res * negative);
}

char	*ft_strchr(const char *s, int c)
{
	while ((*s != '\0') && (*s != c))
	{
		s++;
	}
	if (*s == c)
	{
		return ((char *)s);
	}
	return ((char *) NULL);
}

--- End of /home/tobiasz/TODAY/a_libft3.c ---

Processing /home/tobiasz/TODAY/a_libft4.c...
#include "miniheader.h"

int	ft_isalpha(int c)
{
	if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
		return (1);
	return (0);
}

int	ft_isdigit(int c)
{
	if (c <= '9' && c >= '0')
		return (1);
	return (0);
}

int	ft_isalnum(int c)
{
	if (ft_isalpha(c) || ft_isdigit(c))
		return (1);
	return (0);
}

char	*ft_strcpy(char *dest, const char *src)
{
	int	i;

	i = 0;
	while (src[i] != '\0')
	{
		dest[i] = src[i];
		i++;
	}
	dest[i] = '\0';
	return (dest);
}

char	*ft_strcat(char *dest, const char *src)
{
	int	i;
	int	j;

	i = 0;
	while (dest[i] != '\0')
		i++;
	j = 0;
	while (src[j] != '\0')
	{
		dest[i + j] = src[j];
		j++;
	}
	dest[i + j] = '\0';
	return (dest);
}

--- End of /home/tobiasz/TODAY/a_libft4.c ---

Processing /home/tobiasz/TODAY/a_split.c...
#include "miniheader.h"

static char	**free_all(char **matrice, int i)
{
	while (--i >= 0)
	{
		free(matrice[i]);
		matrice[i] = NULL;
	}
	free(matrice);
	matrice = NULL;
	return (NULL);
}

static char	**ft_matrice(char const *s, char **matrice, int n_token, char c)
{
	int	i;
	int	j;
	int	len;
	int	back;

	i = 0;
	j = 0;
	while (i < n_token)
	{
		while (s[j] == c)
			j++;
		len = 0;
		while (s[j + len] != c && s[j + len] != '\0')
			len++;
		matrice[i] = (char *)malloc((len + 1) * sizeof(char));
		if (!matrice[i])
			return (free_all(matrice, i));
		matrice[i][len] = '\0';
		back = len;
		while (len-- > 0)
			matrice[i][len] = s[j + len];
		j = j + back;
		i++;
	}
	return (matrice);
}

static int	ft_find_token(const char *s, char c)
{
	int	flag;
	int	token;

	flag = 0;
	token = 0;
	while (*s)
	{
		if (*s == c)
			flag = 0;
		else if (flag == 0)
		{
			token++;
			flag = 1;
		}
		s++;
	}
	return (token);
}

char	**ft_split(char const *s, char c)
{
	int		n_token;
	char	**matrice;

	if (s == NULL || *s == '\0')
	{
		matrice = ft_calloc(1, sizeof(char *));
		return (matrice);
	}
	n_token = ft_find_token(s, c);
	matrice = ft_calloc((n_token + 1), sizeof(char *));
	if (!matrice)
		return (NULL);
	matrice[n_token] = NULL;
	return (ft_matrice(s, matrice, n_token, c));
}

--- End of /home/tobiasz/TODAY/a_split.c ---

Processing /home/tobiasz/TODAY/builtin.c...
#include "miniheader.h"

void	execute_cd(char **args_array, t_shell_state *shell_state)
{
	if (args_array[1] == NULL)
	{
		printf("cd: missing argument\n");
		shell_state->last_exit_status = 1;
	}
	else if (args_array[2] != NULL)
	{
		printf("bash: cd: too many arguments\n");
		shell_state->last_exit_status = 1;
	}
	else
	{
		if (chdir(args_array[1]) != 0)
		{
			perror("cd");
			shell_state->last_exit_status = 1;
		}
		else
		{
			shell_state->last_exit_status = 0;
		}
	}
}

void	execute_pwd(t_shell_state *shell_state)
{
	char	cwd[PATH_MAX];

	if (getcwd(cwd, sizeof(cwd)) != NULL)
	{
		printf("%s\n", cwd);
		shell_state->last_exit_status = 0;
	}
	else
	{
		perror("pwd");
		shell_state->last_exit_status = 1;
	}
}

int	parse_echo_options(char **args_array, int *newline)
{
	int	i;
	int	j;

	i = 1;
	*newline = 1;
	while (args_array[i])
	{
		j = 1;
		if ((args_array[i][0] == '-'
			|| (args_array[i][0] == '\'' && args_array[i][1] == '-')
				|| (args_array[i][0] == '\"' && args_array[i][1] == '-')))
		{
			while (args_array[i][j] == 'n' || args_array[i][j] == '\"'
				|| args_array[i][j] == '\'')
				j++;
			if (args_array[i][j] == '\0')
			{
				*newline = 0;
				i++;
				continue ;
			}
		}
		break ;
	}
	return (i);
}

void	execute_echo(char **args_array, t_shell_state *shell_state)
{
	int	i;
	int	newline;

	i = parse_echo_options(args_array, &newline);
	while (args_array[i])
	{
		printf("%s", args_array[i]);
		i++;
		if (args_array[i])
			printf(" ");
	}
	if (newline)
		printf("\n");
	shell_state->last_exit_status = 0;
}

--- End of /home/tobiasz/TODAY/builtin.c ---

Processing /home/tobiasz/TODAY/builtin2.c...
#include "miniheader.h"

void	export_env_var(t_env_var **env_list, const char *name,
			const char *value)
{
	t_env_var	*var;
	t_env_var	*new_var;

	var = find_env_var(*env_list, name);
	if (var)
	{
		free(var->value);
		var->value = ft_strdup(value);
	}
	else
	{
		new_var = malloc(sizeof(t_env_var));
		if (!new_var)
			return ;
		new_var->name = ft_strdup(name);
		new_var->value = ft_strdup(value);
		new_var->next = *env_list;
		*env_list = new_var;
	}
}

void	process_export_value(char **var_value, bool double_quote,
				bool single_quote)
{
	size_t	len;
	char	*clean_value;

	if ((double_quote || single_quote) && var_value && *var_value)
	{
		if ((*var_value)[0] == '"' || (*var_value)[0] == '\'')
		{
			len = ft_strlen(*var_value);
			if ((*var_value)[len - 1] == '"' || (*var_value)[len - 1] == '\'')
			{
				clean_value = ft_strndup((*var_value) + 1, len - 2);
				if (clean_value)
				{
					free(*var_value);
					*var_value = clean_value;
				}
			}
		}
	}
}

void	export_env_var_empty(t_env_var **env_list, const char *name)
{
	t_env_var	*var;
	t_env_var	*new_var;

	var = find_env_var(*env_list, name);
	if (var)
	{
		var->exported_empty = true;
		if (var->value)
		{
			free(var->value);
		}
		var->value = ft_strdup("");
	}
	else
	{
		new_var = malloc(sizeof(t_env_var));
		if (!new_var)
			return ;
		new_var->name = ft_strdup(name);
		new_var->value = ft_strdup("");
		new_var->exported_empty = true;
		new_var->next = *env_list;
		*env_list = new_var;
	}
}

int	parse_export_input(const char *input, char **var_name, char **var_value)
{
	char	*equal_sign;

	equal_sign = ft_strchr(input, '=');
	if (equal_sign)
	{
		*var_name = ft_strndup(input, equal_sign - input);
		*var_value = ft_strdup(equal_sign + 1);
	}
	else
	{
		*var_name = ft_strdup(input);
		*var_value = NULL;
	}
	if (!(*var_name) || !*(*var_name) || !is_valid_var_name(*var_name))
	{
		printf("export: `%s`: not a valid identifier\n", input);
		free(*var_name);
		free(*var_value);
		return (-1);
	}
	return (0);
}

void	handle_export_command(t_env_var **env_list, const char *input,
				bool double_quote, bool single_quote)
{
	char	*var_name;
	char	*var_value;

	var_name = NULL;
	var_value = NULL;
	if (parse_export_input(input, &var_name, &var_value) != 0)
	{
		return ;
	}
	if (var_value == NULL)
	{
		export_env_var_empty(env_list, var_name);
	}
	else
	{
		process_export_value(&var_value, double_quote, single_quote);
		export_env_var(env_list, var_name, var_value);
	}
	free(var_name);
	free(var_value);
}

// void	handle_export_command(t_env_var **env_list, const char *input,
// 			bool double_quote, bool single_quote)
// {
// 	char	*equal_sign;
// 	char	*var_name;
// 	char	*var_value;

// 	equal_sign = ft_strchr(input, '=');
// 	if (equal_sign)
// 	{
// 		var_name = ft_strndup(input, equal_sign - input);
// 		var_value = ft_strdup(equal_sign + 1);
// 	}
// 	else
// 	{
// 		var_name = ft_strdup(input);
// 		var_value = NULL;
// 	}
// 	if (!var_name || !*var_name || !is_valid_var_name(var_name))
// 	{
// 		printf("export: `%s`: not a valid identifier\n", input);
// 		free(var_name);
// 		free(var_value);
// 		return ;
// 	}
// 	if (var_value == NULL)
// 		export_env_var_empty(env_list, var_name);
// 	else
// 	{
// 		if (var_value)
// 			process_export_value(&var_value, double_quote, single_quote);
// 		export_env_var(env_list, var_name, var_value);
// 	}
// 	free(var_name);
// 	free(var_value);
// }

--- End of /home/tobiasz/TODAY/builtin2.c ---

Processing /home/tobiasz/TODAY/builtin3.c...
#include "miniheader.h"

bool	is_valid_var_name(const char *name)
{
	size_t	i;

	if (!name || !name[0])
		return (false);
	if (!(ft_isalpha(name[0]) || name[0] == '_'))
		return (false);
	i = 1;
	while (name[i])
	{
		if (!(ft_isalnum(name[i]) || name[i] == '_'))
			return (false);
		i++;
	}
	return (true);
}

void	free_env_var(t_env_var *env_var)
{
	if (env_var)
	{
		free(env_var->name);
		free(env_var->value);
		free(env_var);
	}
}

void	unset_env_var(t_env_var **env_list, const char *name)
{
	t_env_var	*current;
	t_env_var	*prev;

	if (env_list == NULL || *env_list == NULL || name == NULL)
		return ;
	current = *env_list;
	prev = NULL;
	while (current)
	{
		if (ft_strcmp(current->name, name) == 0)
		{
			if (prev)
				prev->next = current->next;
			else
				*env_list = current->next;
			free_env_var(current);
			return ;
		}
		prev = current;
		current = current->next;
	}
}

void	print_env_vars(t_env_var *env_list)
{
	while (env_list)
	{
		if (env_list->value != NULL && env_list->value[0] != '\0')
			printf("%s=%s\n", env_list->name, env_list->value);
		env_list = env_list->next;
	}
}

void	builtin_env(t_shell_state *shell_state)
{
	print_env_vars(shell_state->env_list);
}

--- End of /home/tobiasz/TODAY/builtin3.c ---

Processing /home/tobiasz/TODAY/builtin4.c...
#include "miniheader.h"

t_env_var	*find_env_var(t_env_var *env_list, const char *name)
{
	t_env_var	*current;

	current = env_list;
	while (current)
	{
		if (ft_strcmp(current->name, name) == 0)
			return (current);
		current = current->next;
	}
	return (NULL);
}

int	is_builtin(char *cmd_name)
{
	if (ft_strcmp(cmd_name, "cd") == 0
		|| ft_strcmp(cmd_name, "pwd") == 0
		|| ft_strcmp(cmd_name, "export") == 0
		|| ft_strcmp(cmd_name, "unset") == 0
		|| ft_strcmp(cmd_name, "env") == 0
		|| ft_strcmp(cmd_name, "exit") == 0
		|| ft_strcmp(cmd_name, "echo") == 0)
		return (1);
	return (0);
}

--- End of /home/tobiasz/TODAY/builtin4.c ---

Processing /home/tobiasz/TODAY/builtin5.c...
#include "miniheader.h"

void	print_exported_vars(t_env_var *env_list)
{
	while (env_list)
	{
		if (env_list->value == NULL && env_list->exported_empty)
			printf("declare -x %s\n", env_list->name);
		else
			printf("declare -x %s=\"%s\"\n", env_list->name, env_list->value);
		env_list = env_list->next;
	}
}

void	execute_export(char **args_array, bool *args_quote_flags,
				t_shell_state *shell_state)
{
	int		i;
	bool	quote_flag;

	if (args_array[1] == NULL)
		print_exported_vars(shell_state->env_list);
	else
	{
		i = 1;
		while (args_array[i] != NULL)
		{
			quote_flag = false;
			if (args_quote_flags != NULL)
				quote_flag = args_quote_flags[i];
			handle_export_command(&shell_state->env_list, args_array[i],
				quote_flag, false);
			i++;
		}
	}
}

void	execute_builtin(t_command *command, char **args_array,
			bool *args_quote_flags, t_shell_state *shell_state)
{
	if (ft_strcmp(command->cmd_name, "cd") == 0)
		execute_cd(args_array, shell_state);
	else if (ft_strcmp(command->cmd_name, "pwd") == 0)
		execute_pwd(shell_state);
	else if (ft_strcmp(command->cmd_name, "exit") == 0)
		execute_exit(args_array, shell_state);
	else if (ft_strcmp(command->cmd_name, "echo") == 0)
		execute_echo(args_array, shell_state);
	else if (ft_strcmp(command->cmd_name, "export") == 0)
		execute_export(args_array, args_quote_flags, shell_state);
	else if (ft_strcmp(command->cmd_name, "env") == 0)
		builtin_env(shell_state);
	else if (ft_strcmp(command->cmd_name, "unset") == 0)
	{
		if (args_array[1] == NULL)
			printf("unset: missing argument\n");
		else
			unset_env_var(&shell_state->env_list, args_array[1]);
	}
}

--- End of /home/tobiasz/TODAY/builtin5.c ---

Processing /home/tobiasz/TODAY/builtin_exit.c...
#include "miniheader.h"

int	validate_exit_code(char **args_array, t_shell_state *shell_state)
{
	int	i;

	i = 0;
	while (args_array[1][i])
	{
		if (!ft_isdigit(args_array[1][i]) && args_array[1][i] != '-')
		{
			printf("Mini exit: %s num required\n", args_array[1]);
			shell_state->exit_shell = true;
			shell_state->exit_code = 2;
			return (-1);
		}
		i++;
	}
	if (args_array[2] != NULL)
	{
		printf("bash: exit: too many arguments\n");
		shell_state->last_exit_status = 1;
		return (-1);
	}
	return (ft_atoi(args_array[1]) % 256);
}

void	execute_exit(char **args_array, t_shell_state *shell_state)
{
	int	exit_code;

	printf("exit\n");
	if (args_array[1] == NULL)
	{
		shell_state->exit_shell = true;
		shell_state->exit_code = 0;
		return ;
	}
	exit_code = validate_exit_code(args_array, shell_state);
	if (exit_code == -1)
		return ;
	shell_state->exit_shell = true;
	shell_state->exit_code = exit_code;
}

--- End of /home/tobiasz/TODAY/builtin_exit.c ---

Processing /home/tobiasz/TODAY/errs.c...
#include "miniheader.h"

void	init_var_for_parsing_tokens(t_token_node *tokens, t_parser_state *state,
			t_command **cmd_list, t_command **last_command)
{
	*cmd_list = NULL;
	*last_command = NULL;
	state->current_token = tokens;
	state->flg_error = false;
	state->error_msg = NULL;
}

void	call_error_and_free(t_parser_state *state, t_command **cmd_list)
{
	printf("Error: %s\n", state->error_msg);
	free_command(*cmd_list);
}

void	init_vars_for_parsing_command(t_command *command)
{
	command->cmd_name = NULL;
	command->has_dollar = false;
	command->args_list = NULL;
	command->redirections = NULL;
	command->next = NULL;
}

void	init_vars_for_not_cmd(t_parser_state *state)
{
	state->flg_error = true;
	state->error_msg = "Malloc failed";
}

void	init_vars_for_cmdname_error(t_parser_state *state, t_command *command)
{
	state->flg_error = true;
	state->error_msg = "Malloc failed";
	free_command(command);
}

--- End of /home/tobiasz/TODAY/errs.c ---

Processing /home/tobiasz/TODAY/errs2.c...
#include "miniheader.h"

void	init_vars_for_expctd_cmdname(t_parser_state *state, t_command *command)
{
	state->flg_error = true;
	state->error_msg = "expected command name";
	free_command(command);
}

void	init_vars_for_error_adding_arg(t_parser_state *state,
					t_command *command)
{
	state->flg_error = true;
	state->error_msg = "Malloc failed";
	free_command(command);
}

void	init_var_failed_add_arg(t_parser_state *state)
{
	state->flg_error = true;
	state->error_msg = "Malloc failed";
}

void	init_var_for_arg_value(char *arg_value, t_list_args *new_arg)
{
	new_arg->arg = arg_value;
	new_arg->next = NULL;
}

void	init_var_for_malloc_rdrctn_err(t_parser_state *state)
{
	state->flg_error = true;
	state->error_msg = "Malloc failed for redirection";
}

--- End of /home/tobiasz/TODAY/errs2.c ---

Processing /home/tobiasz/TODAY/errs3.c...
#include "miniheader.h"

void	init_var_for_parse_redirection(t_redirection *redirection,
					t_parser_state *state)
{
	redirection->filename = NULL;
	redirection->type = state->current_token->type;
	state->current_token = state->current_token->next;
}

void	init_vars_for_strdup_err(t_parser_state *state,
				t_redirection *redirection)
{
	state->flg_error = true;
	state->error_msg = "Malloc failed from strdup";
	free(redirection);
}

void	init_var_expctd_file_or_heredoc(t_parser_state *state,
				t_redirection *redirection)
{
	state->flg_error = true;
	state->error_msg = "Expected filename or delimiter for heredoc";
	free(redirection);
}

--- End of /home/tobiasz/TODAY/errs3.c ---

Processing /home/tobiasz/TODAY/executor.c...
#include "miniheader.h"

#define MAX_LINE_LENGTH 4096
#define MAX_ATTEMPTS 100

int	prepare_arguments(t_command *command, char ***args_array,
				bool **args_quote_flags)
{
	*args_array = convert_arglist_for_exc(command, args_quote_flags);
	if (!*args_array)
	{
		perror("convert_arglist_for_exc");
		return (-1);
	}
	return (0);
}

void exec_bltn_in_parent(t_command* command, char** args_array, bool* args_quote_flags, t_shell_state* shell_state)
{
	t_io_fds	fds;

	init_io_fds(&fds);
	if (handle_builtin_redirections(command, &fds, shell_state) != 0)
	{
		restore_standard_fds(&fds);
		return ;
	}
	execute_builtin(command, args_array, args_quote_flags, shell_state);
	restore_standard_fds(&fds);
}

void exec_in_child(t_command* all_cmds, t_fork_info* finfo, t_shell_state* shell_state)
{
	int			is_builtin_cmd;
	t_io_fds	fds;

	init_io_fds(&fds);
	is_builtin_cmd = is_builtin(finfo->cmd->cmd_name);
	handle_child_redirections(finfo->cmd, &fds, shell_state);
	if (is_builtin_cmd)
	{
		execute_builtin(finfo->cmd, finfo->args_array, finfo->args_quote_flags, shell_state);
		free_args_array(finfo->args_array);
		free(finfo->args_quote_flags);
		free_command_list(all_cmds);
		clean_shell_state(shell_state);
		exit(shell_state->last_exit_status);
	}
	else
	{
		free(finfo->args_quote_flags);
		execute_external_command(all_cmds, finfo->cmd, finfo->args_array, shell_state);
	}
}

void	handle_parent_after_fork(pid_t pid, t_shell_state *shell_state)
{
	int	status;
	int	sig;

	if (pid > 0)
	{
		waitpid(pid, &status, 0);
		if (WIFEXITED(status))
			shell_state->last_exit_status = WEXITSTATUS(status);
		else if (WIFSIGNALED(status))
		{
			sig = WTERMSIG(status);
			shell_state->last_exit_status = 128 + sig;
			if (sig == SIGQUIT)
				write(STDERR_FILENO, "Quit (core dumped)\n", 19);
			else if (sig == SIGINT)
				write(STDOUT_FILENO, "\n", 1);
		}
	}
	else
	{
		perror("fork");
		shell_state->last_exit_status = 1;
	}
}

void	expand_and_write_line(const char *line, int fd,
				bool is_quoted, t_shell_state *shell_state)
{
	char	*expanded_line;

	if (!is_quoted)
	{
		expanded_line = expand_var_in_heredoc(line, shell_state);
		if (expanded_line)
			write(fd, expanded_line, strlen(expanded_line));
		else
			write(fd, line, strlen(line));
	}
	else
		write(fd, line, strlen(line));
	write(fd, "\n", 1);
}

void	handle_sigint_heredoc(int sig)
{
	g_received_signal = sig;
}

void	heredoc_input_loop(const char	*delimiter, int fd,
			bool is_quoted, t_shell_state *shell_state)
{
	char	line[MAX_LINE_LENGTH];
	size_t	line_len;
	bool	should_exit;

	should_exit = false;
	while (1)
	{
		write(1, "> ", 2);
		should_exit = read_input_line(line, &line_len);
		if (should_exit || g_received_signal == SIGINT)
		{
			write(1, "\n", 1);
			break ;
		}
		if (strcmp(line, delimiter) == 0)
			break ;
		expand_and_write_line(line, fd, is_quoted, shell_state);
	}
}

void	read_and_expand_heredoc(const char *delimiter, int fd,
				bool is_quoted, t_shell_state *shell_state)
{
	struct sigaction	sa_int;
	struct sigaction	sa_quit;
	struct sigaction	sa_old_int;
	struct sigaction	sa_old_quit;

	sa_int.sa_handler = handle_sigint_heredoc;
	sigemptyset(&sa_int.sa_mask);
	sa_int.sa_flags = 0;
	sigaction(SIGINT, &sa_int, &sa_old_int);
	sa_quit.sa_handler = SIG_IGN;
	sigemptyset(&sa_quit.sa_mask);
	sa_quit.sa_flags = 0;
	sigaction(SIGQUIT, &sa_quit, &sa_old_quit);
	heredoc_input_loop(delimiter, fd, is_quoted, shell_state);
	sigaction(SIGINT, &sa_old_int, NULL);
	sigaction(SIGQUIT, &sa_old_quit, NULL);
}

void	init_int_to_str_vars(t_int_to_str_vars *vars, int num)
{
	vars->i = 0;
	vars->is_negative = 0;
	vars->temp_num = num;
	if (num == 0)
	{
		vars->temp_str[vars->i++] = '0';
		vars->temp_str[vars->i] = '\0';
	}
	else if (num < 0)
	{
		vars->is_negative = 1;
		vars->temp_num = -num;
	}
}

void	int_to_str(int num, char *str)
{
	t_int_to_str_vars	vars;

	init_int_to_str_vars(&vars, num);
	if (num == 0)
	{
		str[0] = vars.temp_str[0];
		str[1] = '\0';
		return ;
	}
	while (vars.temp_num > 0)
	{
		vars.temp_str[vars.i++] = (vars.temp_num % 10) + '0';
		vars.temp_num /= 10;
	}
	if (vars.is_negative)
		vars.temp_str[vars.i++] = '-';
	vars.j = 0;
	while (vars.i > 0)
		str[vars.j++] = vars.temp_str[--vars.i];
	str[vars.j] = '\0';
}

int	generate_unique_filename(t_filename_vars *vars)
{
	vars->unique_id = 0;
	while (vars->unique_id < MAX_ATTEMPTS)
	{
		ft_strcpy(vars->tmp_filename, "/tmp/heredoc_");
		int_to_str(vars->unique_id, vars->unique_id_str);
		ft_strcat(vars->tmp_filename, vars->unique_id_str);
		vars->fd = open(vars->tmp_filename, O_CREAT | O_EXCL | O_RDWR, 0600);
		if (vars->fd != -1)
			return (0);
		if (errno != EEXIST)
		{
			perror("open");
			return (-1);
		}
		vars->unique_id++;
	}
	write(2, "Failed to create unique heredoc file\n", 37);
	return (-1);
}

int	create_temp_heredoc_file(char **heredoc_filename)
{
	t_filename_vars	vars;

	if (generate_unique_filename(&vars) != 0)
	{
		*heredoc_filename = NULL;
		return (-1);
	}
	*heredoc_filename = ft_strdup(vars.tmp_filename);
	if (!*heredoc_filename)
	{
		perror("ft_strdup");
		close(vars.fd);
		unlink(vars.tmp_filename);
		*heredoc_filename = NULL;
		return (-1);
	}
	return (vars.fd);
}

void	handle_heredoc(t_redirection *redirection,
			char **heredoc_filename, t_shell_state *shell_state)
{
	int	fd;

	fd = create_temp_heredoc_file(heredoc_filename);
	if (fd == -1)
		return ;
	read_and_expand_heredoc(redirection->filename, fd,
		redirection->is_quoted, shell_state);
	close(fd);
}

int	process_command_heredocs(t_command *current_cmd, t_shell_state *shell_state)
{
	t_redirection	*redirection;
	char			*heredoc_filename;

	redirection = current_cmd->redirections;
	while (redirection)
	{
		if (redirection->type == TOKEN_HEREDOC)
		{
			heredoc_filename = NULL;
			handle_heredoc(redirection, &heredoc_filename, shell_state);
			if (!heredoc_filename)
			{
				write(2, "failed to create heredoc file 4 redir\n", 38);
				return (-1);
			}
			redirection->heredoc_filename = heredoc_filename;
		}
		redirection = redirection->next;
	}
	return (0);
}

int	process_all_heredocs(t_command *command_list, t_shell_state *shell_state)
{
	t_command		*current_cmd;

	current_cmd = command_list;
	while (current_cmd)
	{
		if (process_command_heredocs(current_cmd, shell_state) < 0)
			return (1);
		current_cmd = current_cmd->next;
	}
	return (0);
}

void execute_single_command(t_command* all_cmds, t_command* command, t_shell_state* shell_state)
{
	char			**args_array;
	bool			*args_quote_flags;
	int				is_builtin_cmd;
	t_redirection	*redirection;
	t_fork_info		fork_info;

	redirection = command->redirections;
	if (initialize_command_args(command, &args_array, &args_quote_flags) != 0)
		return ;
	is_builtin_cmd = is_builtin(command->cmd_name);
	fork_info = (t_fork_info){command, args_array, args_quote_flags};
	if (is_builtin_cmd && command->next == NULL)
		exec_bltn_in_parent(command, args_array, args_quote_flags, shell_state);
	else
		handle_fork(all_cmds, &fork_info, shell_state);
	while (redirection)
	{
		if (redirection->type == TOKEN_HEREDOC)
		{
			unlink(redirection->heredoc_filename);
			free(redirection->heredoc_filename);
			redirection->heredoc_filename = NULL;
		}
		redirection = redirection->next;
	}
	free_args_array(args_array);
	free(args_quote_flags);
}

--- End of /home/tobiasz/TODAY/executor.c ---

Processing /home/tobiasz/TODAY/executor10_heredoc_expansion.c...
#include "miniheader.h"

#define MAX_EXPANDED_LINE 4096

static char	*get_env_var(t_shell_state *shell_state, const char *var_name)
{
	t_env_var	*env;

	env = shell_state->env_list;
	while (env)
	{
		if (ft_strcmp(env->name, var_name) == 0)
		{
			return (env->value);
		}
		env = env->next;
	}
	return ("");
}

static size_t	extract_var_name(const char *input, size_t i, char *var_name)
{
	int	var_len;

	var_len = 0;
	while ((input[i] >= 'A' && input[i] <= 'Z')
		|| (input[i] >= 'a' && input[i] <= 'z')
		|| (input[i] >= '0' && input[i] <= '9')
		|| (input[i] == '_'))
	{
		if (var_len < 255)
			var_name[var_len++] = input[i];
		i++;
	}
	var_name[var_len] = '\0';
	return (i);
}

static size_t	expand_env_var(const char *input, size_t i,
				t_expand_state *state)
{
	char	var_name[256];
	char	*var_value;
	size_t	var_value_len;
	size_t	remaining;

	i = extract_var_name(input, i, var_name);
	var_value = get_env_var(state->shell_state, var_name);
	var_value_len = ft_strlen(var_value);
	if (state->j + var_value_len >= MAX_EXPANDED_LINE - 1)
	{
		remaining = MAX_EXPANDED_LINE - 1 - state->j;
		if (remaining > 0)
		{
			ft_memcpy(&(state->output[state->j]), var_value, remaining);
			state->j += remaining;
		}
	}
	else
	{
		ft_memcpy(&(state->output[state->j]), var_value, var_value_len);
		state->j += var_value_len;
	}
	return (i);
}

char	*expand_var_in_heredoc(const char *input, t_shell_state *shell_state)
{
	static char		output[MAX_EXPANDED_LINE];
	t_expand_state	state;

	state.len = ft_strlen(input);
	state.i = 0;
	state.j = 0;
	state.in_quotes = false;
	state.output = output;
	state.shell_state = shell_state;
	while (state.i < state.len && state.j < MAX_EXPANDED_LINE - 1)
	{
		if (input[state.i] == '\'' || input[state.i] == '"')
		{
			state.in_quotes = !state.in_quotes;
			state.output[state.j++] = input[state.i++];
			continue ;
		}
		if (input[state.i] == '$')
			state.i = expand_env_var(input, state.i + 1, &state);
		else
			state.output[state.j++] = input[state.i++];
	}
	state.output[state.j] = '\0';
	return (state.output);
}

--- End of /home/tobiasz/TODAY/executor10_heredoc_expansion.c ---

Processing /home/tobiasz/TODAY/executor11_read_write_heredoc.c...
#include "miniheader.h"

#define MAX_LINE_LENGTH 4096

bool	handle_read_error(ssize_t bytes_read)
{
	if (bytes_read == -1 && errno == EINTR)
	{
		return (true);
	}
	else if (bytes_read == -1)
	{
		perror("read");
		return (true);
	}
	return (false);
}

bool	read_input_line(char *line, size_t *line_len)
{
	char	buffer[1];
	ssize_t	bytes_read;
	bool	should_exit;

	*line_len = 0;
	should_exit = false;
	while (1)
	{
		bytes_read = read_single_char(buffer);
		if (handle_read_error(bytes_read))
		{
			should_exit = true;
			break ;
		}
		should_exit = update_exit_status(bytes_read, *line_len);
		if (should_exit)
			break ;
		if (is_newline_char(buffer[0]))
			break ;
		else
			add_char_to_line(buffer[0], line, line_len);
	}
	line[*line_len] = '\0';
	return (should_exit);
}

--- End of /home/tobiasz/TODAY/executor11_read_write_heredoc.c ---

Processing /home/tobiasz/TODAY/executor12_read_and_expand_utils.c...
#include "miniheader.h"

#define MAX_LINE_LENGTH 4096

ssize_t	read_single_char(char *buffer)
{
	ssize_t	bytes_read;

	bytes_read = read(STDIN_FILENO, buffer, 1);
	if (bytes_read == -1 && errno != EINTR)
	{
		perror("read");
	}
	return (bytes_read);
}

bool	is_newline_char(char buffer_char)
{
	return (buffer_char == '\n');
}

void	add_char_to_line(char buffer_char, char *line, size_t *line_len)
{
	if (*line_len < MAX_LINE_LENGTH - 1)
	{
		line[(*line_len)++] = buffer_char;
	}
}

bool	check_exit_condition(size_t line_len)
{
	return (line_len == 0);
}

bool	update_exit_status(ssize_t bytes_read, size_t line_len)
{
	if (bytes_read == 0 && check_exit_condition(line_len))
		return (true);
	return (false);
}

--- End of /home/tobiasz/TODAY/executor12_read_and_expand_utils.c ---

Processing /home/tobiasz/TODAY/executor2.c...
#include "miniheader.h"

void	init_io_fds(t_io_fds *fds)
{
	fds->infile_fd = -1;
	fds->outfile_fd = -1;
	fds->heredoc_fd = -1;
	fds->stdin_backup = -1;
	fds->stdout_backup = -1;
}

void	restore_standard_fds(t_io_fds *fds)
{
	if (fds->stdin_backup != -1)
	{
		if (dup2(fds->stdin_backup, STDIN_FILENO) < 0)
		{
			perror("Error restoring stdin");
			close(fds->stdin_backup);
			fds->stdin_backup = -1;
			return ;
		}
		close(fds->stdin_backup);
		fds->stdin_backup = -1;
	}
	if (fds->stdout_backup != -1)
	{
		if (dup2(fds->stdout_backup, STDOUT_FILENO) < 0)
		{
			perror("Error restoring stdout");
			close(fds->stdout_backup);
			fds->stdout_backup = -1;
			return ;
		}
		close(fds->stdout_backup);
		fds->stdout_backup = -1;
	}
}

void	execute_builtin_command(t_command *command, char **args_array,
				bool *args_quote_flags, t_shell_state *shell_state)
{
	execute_builtin(command, args_array, args_quote_flags, shell_state);
	shell_state->last_exit_status = 0;
}

void execute_external_command(t_command* all_cmds, t_command* command, char** args_array, t_shell_state* shell_state)
{
	char	*full_path;
	char	**envp;

	envp = build_envp(shell_state);
	if (!envp)
	{
		perror("build_envp");
		free_command_list(all_cmds);
		free_args_array(args_array);
		free_args_array(envp);
		exit(EXIT_FAILURE);
	}
	full_path = get_command_path(command->cmd_name, shell_state);
	clean_shell_state(shell_state);
	shell_state->env_list = NULL;
	if (!full_path)
	{
		printf("Command not found: %s\n", command->cmd_name);
		free_command_list(all_cmds);
		free_args_array(args_array);
		free_args_array(envp);
		clean_shell_state(shell_state);
		exit(127);
	}
	execve(full_path, args_array, envp);
	perror("execve");
	free(full_path);
	free_command_list(all_cmds);
	free_args_array(args_array);
	free_args_array(envp);
	exit(EXIT_FAILURE);
}

--- End of /home/tobiasz/TODAY/executor2.c ---

Processing /home/tobiasz/TODAY/executor2_signals.c...
#include "miniheader.h"

int	initialize_command_args(t_command *command, char ***args_array,
				bool **args_quote_flags)
{
	if (prepare_arguments(command, args_array, args_quote_flags) != 0)
		return (-1);
	return (0);
}

void	handle_signals_in_child(void)
{
	signal(SIGINT, SIG_DFL);
	signal(SIGQUIT, SIG_DFL);
	signal(SIGPIPE, SIG_DFL);
}

void	restore_signals_after_command(void)
{
	struct sigaction	sa_int;
	struct sigaction	sa_quit;

	sa_int.sa_handler = handle_sigint;
	sigemptyset(&sa_int.sa_mask);
	sa_int.sa_flags = 0;
	sigaction(SIGINT, &sa_int, NULL);
	sa_quit.sa_handler = handle_sigquit;
	sigemptyset(&sa_quit.sa_mask);
	sa_quit.sa_flags = 0;
	sigaction(SIGQUIT, &sa_quit, NULL);
}

void	handle_signals_in_parent(void)
{
	signal(SIGINT, SIG_IGN);
	signal(SIGQUIT, SIG_IGN);
}

void handle_fork(t_command* all_cmds, t_fork_info* finfo, t_shell_state* shell_state)
{
	pid_t	pid;

	pid = fork();
	if (pid == 0)
	{
		handle_signals_in_child();
		exec_in_child(all_cmds, finfo, shell_state);
	}
	else if (pid > 0)
	{
		handle_signals_in_parent();
		handle_parent_after_fork(pid, shell_state);
		restore_signals_after_command();
	}
	else
	{
		perror("fork");
		shell_state->last_exit_status = 1;
	}
}

--- End of /home/tobiasz/TODAY/executor2_signals.c ---

Processing /home/tobiasz/TODAY/executor2env.c...
#include "miniheader.h"

int	count_env_vars(t_env_var *env_list)
{
	int			count;
	t_env_var	*current;

	current = env_list;
	count = 0;
	while (current)
	{
		count++;
		current = current->next;
	}
	return (count);
}

char	*create_env_var_string(t_env_var *env_var)
{
	size_t	name_len;
	size_t	value_len;
	size_t	len;
	char	*env_string;

	name_len = ft_strlen(env_var->name);
	if (env_var->value)
		value_len = strlen(env_var->value);
	else
		value_len = 0;
	len = name_len + 1 + value_len + 1;
	env_string = malloc(len);
	if (!env_string)
		return (NULL);
	memcpy(env_string, env_var->name, name_len);
	env_string[name_len] = '=';
	if (value_len > 0)
		memcpy(env_string + name_len + 1, env_var->value, value_len);
	env_string[name_len + 1 + value_len] = '\0';
	return (env_string);
}

void	free_envp_on_error(char **envp, int i)
{
	while (i > 0)
	{
		i--;
		free(envp[i]);
	}
	free(envp);
}

char	**build_envp(t_shell_state *shell_state)
{
	int			count;
	char		**envp;
	t_env_var	*current;
	int			i;

	count = count_env_vars(shell_state->env_list);
	envp = malloc(sizeof(char *) * (count + 1));
	if (!envp)
		return (NULL);
	current = shell_state->env_list;
	i = 0;
	while (current)
	{
		envp[i] = create_env_var_string(current);
		if (!envp[i])
		{
			free_envp_on_error(envp, i);
			return (NULL);
		}
		i++;
		current = current->next;
	}
	envp[i] = NULL;
	return (envp);
}

--- End of /home/tobiasz/TODAY/executor2env.c ---

Processing /home/tobiasz/TODAY/executor3_pipe.c...
#include "miniheader.h"

void	finalize_pipeline(int prev_pipe_fd[2], t_shell_state *shell_state)
{
	if (prev_pipe_fd[0] != -1)
		close_prev_pipe_fd(prev_pipe_fd);
	wait_for_all_children(shell_state);
	signal(SIGINT, handle_sigint);
	signal(SIGQUIT, handle_sigquit);
}

void handle_child_process(t_command* all_cmds, t_pipe_cmd* pcmd, t_shell_state* shell_state)
{
	signal(SIGINT, SIG_DFL);
	signal(SIGQUIT, SIG_DFL);
	setup_child_prcs(all_cmds, pcmd, shell_state);
}

void	handle_parent_process(pid_t pid, int prev_pipe_fd[2], int pipe_fd[2])
{
	(void)pid;
	signal(SIGINT, SIG_IGN);
	signal(SIGQUIT, SIG_IGN);
	parent_cleanup(prev_pipe_fd, pipe_fd);
}

void	execute_pipeline_loop(t_command *current_cmd, int prev_pipe_fd[2],
				t_command *command_list, t_shell_state *shell_state)
{
	int		pipe_fd[2];
	pid_t	pid;
	t_pipe_cmd pcmd;

	while (current_cmd)
	{
		pipe_fd[0] = -1;
		pipe_fd[1] = -1;
		create_pipe_if_needed(current_cmd, pipe_fd);
		pcmd = (t_pipe_cmd){current_cmd, prev_pipe_fd, pipe_fd};
		pid = fork();
		if (pid == 0)
			handle_child_process(command_list, &pcmd, shell_state);
		else if (pid > 0)
			handle_parent_process(pid, prev_pipe_fd, pipe_fd);
		else
			call_perror_exec_pipeline(command_list);
		current_cmd = current_cmd->next;
	}
}

void	execute_pipeline(t_command *command_list, t_shell_state *shell_state)
{
	t_command	*current_cmd;
	int			prev_pipe_fd[2];

	init_pipeline(&current_cmd, prev_pipe_fd, command_list);
	execute_pipeline_loop(current_cmd, prev_pipe_fd, command_list, shell_state);
	finalize_pipeline(prev_pipe_fd, shell_state);
}

--- End of /home/tobiasz/TODAY/executor3_pipe.c ---

Processing /home/tobiasz/TODAY/executor3_setup_child.c...
#include "miniheader.h"

void	init_fds_bye_norminette(t_io_fds *fds)
{
	fds->infile_fd = -1;
	fds->outfile_fd = -1;
	fds->heredoc_fd = -1;
	fds->stdin_backup = -1;
	fds->stdout_backup = -1;
}

void	close_pipe_fds(int prev_pipe_fd[2], int pipe_fd[2])
{
	if (prev_pipe_fd[0] != -1)
	{
		close(prev_pipe_fd[0]);
		close(prev_pipe_fd[1]);
	}
	if (pipe_fd[0] != -1)
	{
		close(pipe_fd[0]);
		close(pipe_fd[1]);
	}
}

void setup_child_prcs(t_command* all_cmds, t_pipe_cmd* pcmd, t_shell_state* shell_state)
{
	t_io_fds	fds;

	init_fds_bye_norminette(&fds);
	if (pcmd->prev_pipe_fd[0] != -1)
	{
		if (dup2(pcmd->prev_pipe_fd[0], STDIN_FILENO) == -1)
			call_perror_child_process_fd1(pcmd->cmd);
	}
	if (pcmd->pipe_fd[1] != -1)
	{
		if (dup2(pcmd->pipe_fd[1], STDOUT_FILENO) == -1)
			call_perror_child_process_fd2(pcmd->cmd);
	}
	close_pipe_fds(pcmd->prev_pipe_fd, pcmd->pipe_fd);
	handle_child_redirections(pcmd->cmd, &fds, shell_state);
	execute_single_command(all_cmds, pcmd->cmd, shell_state);
	free_command_list(all_cmds);
	clean_shell_state(shell_state);
	exit(shell_state->last_exit_status);
}

--- End of /home/tobiasz/TODAY/executor3_setup_child.c ---

Processing /home/tobiasz/TODAY/executor3_wait.c...
#include "miniheader.h"

void	create_pipe_if_needed(t_command *current_cmd, int pipe_fd[2])
{
	if (current_cmd->next)
	{
		if (pipe(pipe_fd) == -1)
		{
			perror("pipe");
			exit(EXIT_FAILURE);
		}
	}
	else
	{
		pipe_fd[0] = -1;
		pipe_fd[1] = -1;
	}
}

void	wait_for_all_children(t_shell_state *shell_state)
{
	int	status;
	int	sig;

	while (wait(&status) > 0)
	{
		if (WIFEXITED(status))
			shell_state->last_exit_status = WEXITSTATUS(status);
		else if (WIFSIGNALED(status))
		{
			sig = WTERMSIG(status);
			shell_state->last_exit_status = 128 + sig;
			if (sig == SIGQUIT)
				write(STDOUT_FILENO, "Quit (core dumped)\n", 19);
			else if (sig == SIGINT)
				write(STDOUT_FILENO, "\n", 1);
		}
	}
}

void	init_pipeline(t_command **current_cmd,
			int prev_pipe_fd[2], t_command *command_list)
{
	prev_pipe_fd[0] = -1;
	prev_pipe_fd[1] = -1;
	*current_cmd = command_list;
}

--- End of /home/tobiasz/TODAY/executor3_wait.c ---

Processing /home/tobiasz/TODAY/executor4_pipe_utils.c...
#include "miniheader.h"

void	call_perror_child_process_fd1(t_command *current_cmd)
{
	perror("dup2");
	free_command_list(current_cmd);
	exit(EXIT_FAILURE);
}

void	call_perror_child_process_fd2(t_command *current_cmd)
{
	perror("dup2");
	free_command_list(current_cmd);
	exit(EXIT_FAILURE);
}

void	parent_cleanup(int prev_pipe_fd[2], int pipe_fd[2])
{
	if (prev_pipe_fd[0] != -1)
	{
		close(prev_pipe_fd[0]);
		close(prev_pipe_fd[1]);
	}
	prev_pipe_fd[0] = pipe_fd[0];
	prev_pipe_fd[1] = pipe_fd[1];
}

void	call_perror_exec_pipeline(t_command *command_list)
{
	perror("fork");
	free_command_list(command_list);
	exit(EXIT_FAILURE);
}

void	close_prev_pipe_fd(int prev_pipe_fd[2])
{
	close(prev_pipe_fd[0]);
	close(prev_pipe_fd[1]);
}

--- End of /home/tobiasz/TODAY/executor4_pipe_utils.c ---

Processing /home/tobiasz/TODAY/executor5_redir_builtin.c...
#include "miniheader.h"

int	backup_fd(int old_fd, int *backup_fd, const char *error_msg)
{
	if (*backup_fd == -1)
	{
		*backup_fd = dup(old_fd);
		if (*backup_fd < 0)
		{
			perror(error_msg);
			return (-1);
		}
	}
	return (0);
}

int	handle_builtin_redirections(t_command *command, t_io_fds *fds,
					t_shell_state *shell_state)
{
	t_redirection	*redirection;

	redirection = command->redirections;
	while (redirection)
	{
		if (apply_redirection(redirection, fds, shell_state) < 0)
			return (-1);
		redirection = redirection->next;
	}
	return (0);
}

int	redirect_input(t_redirection *redirection, t_io_fds *fds)
{
	if (backup_fd(STDIN_FILENO, &fds->stdin_backup, "Err backing up stdin") < 0)
		return (-1);
	fds->infile_fd = open(redirection->filename, O_RDONLY);
	if (fds->infile_fd < 0)
	{
		perror("Error opening input file");
		return (-1);
	}
	if (dup2(fds->infile_fd, STDIN_FILENO) < 0)
	{
		perror("Error redirecting stdin");
		close(fds->infile_fd);
		return (-1);
	}
	close(fds->infile_fd);
	return (0);
}

int	redirect_output(t_redirection *redirection, t_io_fds *fds)
{
	int	flags;

	if (redirection->type == TOKEN_REDIR_OUT)
		flags = O_WRONLY | O_CREAT | O_TRUNC;
	else if (redirection->type == TOKEN_REDIR_APPEND)
		flags = O_WRONLY | O_CREAT | O_APPEND;
	else
		return (-1);
	if (backup_fd(STDOUT_FILENO, &fds->stdout_backup,
			"Error backing up stdout") < 0)
		return (-1);
	fds->outfile_fd = open(redirection->filename, flags, 0644);
	if (fds->outfile_fd < 0)
	{
		perror("Error opening output file");
		return (-1);
	}
	if (dup2(fds->outfile_fd, STDOUT_FILENO) < 0)
	{
		perror("Error redirecting stdout");
		close(fds->outfile_fd);
		return (-1);
	}
	close(fds->outfile_fd);
	return (0);
}

int	perform_heredoc_redirection(const char *heredoc_filename)
{
	int	heredoc_fd;

	heredoc_fd = open(heredoc_filename, O_RDONLY);
	if (heredoc_fd < 0)
	{
		perror ("error opening heredoc file");
		return (-1);
	}
	if (dup2(heredoc_fd, STDIN_FILENO) < 0)
	{
		perror("error redirecting stdin for heredoc");
		close(heredoc_fd);
		return (-1);
	}
	close (heredoc_fd);
	unlink(heredoc_filename);
	return (0);
}

int	handle_heredoc_redirection(t_redirection *redirection, t_io_fds *fds,
			t_shell_state *shell_state)
{
	char	*heredoc_filename;

	heredoc_filename = NULL;
	if (backup_fd(STDIN_FILENO, &fds->stdin_backup,
			"Error backing up stdin for heredoc") < 0)
		return (-1);
	handle_heredoc(redirection, &heredoc_filename, shell_state);
	if (heredoc_filename == NULL)
	{
		write(2, "Error handling heredoc\n", 23);
		return (-1);
	}
	if (perform_heredoc_redirection(heredoc_filename) < 0)
	{
		free(heredoc_filename);
		return (-1);
	}
	free(heredoc_filename);
	return (0);
}

--- End of /home/tobiasz/TODAY/executor5_redir_builtin.c ---

Processing /home/tobiasz/TODAY/executor6_redir_builtin_utils.c...
#include "miniheader.h"

int	apply_heredoc_file(t_redirection *redirection)
{
	int	fd;

	fd = open(redirection->heredoc_filename, O_RDONLY);
	if (fd < 0)
	{
		perror("open heredoc file");
		return (-1);
	}
	if (dup2(fd, STDIN_FILENO) < 0)
	{
		perror("dup2 heredoc file");
		close(fd);
		return (-1);
	}
	close(fd);
	unlink(redirection->heredoc_filename);
	return (0);
}

int	apply_redirection(t_redirection *redirection, t_io_fds *fds,
			t_shell_state *shell_state)
{
	(void)shell_state;
	if (redirection->type == TOKEN_REDIR_IN)
		return (redirect_input(redirection, fds));
	else if (redirection->type == TOKEN_REDIR_OUT
		|| redirection->type == TOKEN_REDIR_APPEND)
		return (redirect_output(redirection, fds));
	else if (redirection->type == TOKEN_HEREDOC)
		return (apply_heredoc_file(redirection));
	return (0);
}

--- End of /home/tobiasz/TODAY/executor6_redir_builtin_utils.c ---

Processing /home/tobiasz/TODAY/executor7_redir_child.c...
#include "miniheader.h"

int	handle_input_redirection(t_redirection *redirection)
{
	int	fd;

	fd = open_file(redirection->filename, O_RDONLY, 0);
	if (fd < 0)
		return (-1);
	return (apply_dup2(fd, STDIN_FILENO));
}

int	hndl_out_redir(t_redirection *redirection, int flags)
{
	int	fd;

	fd = open_file(redirection->filename, flags, 0644);
	if (fd < 0)
		return (-1);
	return (apply_dup2(fd, STDOUT_FILENO));
}

int	create_and_open_heredoc(t_redirection *redirection,
		t_shell_state *shell_state, int *heredoc_fd, char **heredoc_filename)
{
	*heredoc_filename = NULL;
	handle_heredoc(redirection, heredoc_filename, shell_state);
	if (*heredoc_filename == NULL)
	{
		if (g_received_signal != 0)
		{
			errno = EINTR;
			perror("Error creating heredoc");
		}
		else
		{
			perror("Error creating heredoc");
		}
		return (-1);
	}
	*heredoc_fd = open(*heredoc_filename, O_RDONLY);
	if (*heredoc_fd < 0)
	{
		perror("Error opening heredoc file");
		free(*heredoc_filename);
		return (-1);
	}
	return (0);
}

int	perform_heredoc_redirection2(int heredoc_fd, char *heredoc_filename)
{
	if (dup2(heredoc_fd, STDIN_FILENO) < 0)
	{
		perror("Error redirecting stdin for heredoc");
		close(heredoc_fd);
		free(heredoc_filename);
		return (-1);
	}
	close(heredoc_fd);
	unlink(heredoc_filename);
	free(heredoc_filename);
	return (0);
}

int	handle_heredoc_redirection2(t_redirection *redirection, t_io_fds *fds,
			t_shell_state *shell_state)
{
	char	*heredoc_filename;
	int		heredoc_fd;

	if (backup_fd(STDIN_FILENO, &fds->stdin_backup,
			"Error backing up stdin for heredoc") < 0)
		return (-1);
	if (create_and_open_heredoc(redirection, shell_state,
			&heredoc_fd, &heredoc_filename) < 0)
		return (-1);
	if (perform_heredoc_redirection2(heredoc_fd, heredoc_filename) < 0)
		return (-1);
	return (0);
}

void	finalize_input_redirection(int last_input_fd)
{
	if (last_input_fd != -1)
	{
		if (dup2(last_input_fd, STDIN_FILENO) < 0)
		{
			perror("dup2");
			exit(EXIT_FAILURE);
		}
		close(last_input_fd);
	}
}

int	open_input_file(const char *filename)
{
	int	fd;

	fd = open(filename, O_RDONLY);
	if (fd < 0)
	{
		perror("Error opening input file");
		exit(EXIT_FAILURE);
	}
	return (fd);
}

void	process_input_redirection(t_redirection *redirection,
			int *last_input_fd)
{
	const char	*filename;

	filename = NULL;
	if (*last_input_fd != -1)
		close(*last_input_fd);
	if (redirection->type == TOKEN_REDIR_IN)
		filename = redirection->filename;
	else if (redirection->type == TOKEN_HEREDOC)
	{
		if (redirection->heredoc_filename == NULL)
		{
			write(2, "Errorheoc_filme NULL hdle_child_redions\n", 41);
			exit(EXIT_FAILURE);
		}
		else
			fprintf(stderr, "Opening heredoc file: %s\n", redirection->heredoc_filename);
		filename = redirection->heredoc_filename;
	}
	else
		return ;
	*last_input_fd = open_input_file(filename);
}

void	process_redirection(t_redirection *redirection,
			int *last_input_fd, t_io_fds *fds, t_shell_state *shell_state)
{
	if (redirection->type == TOKEN_REDIR_IN
		|| redirection->type == TOKEN_HEREDOC)
	{
		process_input_redirection(redirection, last_input_fd);
	}
	else if (redirection->type == TOKEN_REDIR_OUT
		|| redirection->type == TOKEN_REDIR_APPEND)
	{
		if (apply_redirection(redirection, fds, shell_state) < 0)
		{
			exit(EXIT_FAILURE);
		}
	}
}

void	handle_child_redirections(t_command *command,
			t_io_fds *fds, t_shell_state *shell_state)
{
	t_redirection	*redirection;
	int				last_input_fd;

	redirection = command->redirections;
	last_input_fd = -1;
	while (redirection)
	{
		process_redirection(redirection, &last_input_fd, fds, shell_state);
		redirection = redirection->next;
	}
	finalize_input_redirection(last_input_fd);
}

--- End of /home/tobiasz/TODAY/executor7_redir_child.c ---

Processing /home/tobiasz/TODAY/executor8_redir_child_utils.c...
#include "miniheader.h"

int	open_file(const char *filename, int flags, mode_t mode)
{
	int	fd;

	fd = open(filename, flags, mode);
	if (fd < 0)
		perror("Error opening file");
	return (fd);
}

int	apply_dup2(int fd, int target_fd)
{
	if (dup2(fd, target_fd) < 0)
	{
		perror("dup2");
		close(fd);
		return (-1);
	}
	close(fd);
	return (0);
}

int	process_single_redirection(t_redirection *redirection, t_io_fds *fds,
					t_shell_state *shell_state)
{
	if (redirection->type == TOKEN_REDIR_IN)
		return (handle_input_redirection(redirection));
	else if (redirection->type == TOKEN_REDIR_OUT)
		return (hndl_out_redir(redirection, O_WRONLY | O_CREAT | O_TRUNC));
	else if (redirection->type == TOKEN_REDIR_APPEND)
		return (hndl_out_redir(redirection, O_WRONLY | O_CREAT | O_APPEND));
	else if (redirection->type == TOKEN_HEREDOC)
		return (handle_heredoc_redirection2(redirection, fds, shell_state));
	return (0);
}

--- End of /home/tobiasz/TODAY/executor8_redir_child_utils.c ---

Processing /home/tobiasz/TODAY/expander.c...
#include "miniheader.h"

void	process_input_string(char *str, char *result, char *exit_status_str)
{
	int	i;
	int	j;

	i = 0;
	j = 0;
	while (str[i])
	{
		if (str[i] == '$' && str[i + 1] == '?')
		{
			copy_exit_status(result, &j, exit_status_str);
			i += 2;
		}
		else
		{
			result[j] = str[i];
			j++;
			i++;
		}
	}
	result[j] = '\0';
}

int	i_ex(char **result, int expanded_length,
			char **exit_status_str, t_shell_state *shell_state)
{
	*result = malloc(expanded_length + 1);
	if (!*result)
		return (-1);
	*exit_status_str = ft_itoa(shell_state->last_exit_status);
	if (!*exit_status_str)
	{
		free(*result);
		return (-1);
	}
	return (0);
}

static int	calculate_expanded_length(char *str, t_shell_state *shell_state)
{
	int		len;
	int		i;
	int		exit_len;
	char	*exit_status_str;

	init_dasvidaniya_norminette(&len, &i);
	exit_status_str = ft_itoa(shell_state->last_exit_status);
	if (!exit_status_str)
		return (-1);
	exit_len = ft_strlen(exit_status_str);
	free(exit_status_str);
	while (str[i])
	{
		if (str[i] == '$' && str[i + 1] == '?')
		{
			len += exit_len;
			i += 2;
		}
		else
		{
			len++;
			i++;
		}
	}
	return (len);
}

char	*expand_var_in_string(char *str, t_shell_state *shell_state)
{
	char	*result;
	int		expanded_length;
	char	*exit_status_str;
	int		init_result;

	if (!str)
		return (NULL);
	expanded_length = calculate_expanded_length(str, shell_state);
	if (expanded_length == -1)
		return (NULL);
	init_result = i_ex(&result, expanded_length, &exit_status_str, shell_state);
	if (init_result == -1)
		return (NULL);
	process_input_string(str, result, exit_status_str);
	free(exit_status_str);
	return (result);
}

void	expand_exit_status(t_token_node *tokens, t_shell_state *shell_state)
{
	t_token_node	*current;
	char			*expanded_token;

	current = tokens;
	while (current)
	{
		if (current->double_quote)
		{
			expanded_token = expand_var_in_string(current->token, shell_state);
			free(current->token);
			current->token = expanded_token;
		}
		current = current->next;
	}
}

--- End of /home/tobiasz/TODAY/expander.c ---

Processing /home/tobiasz/TODAY/expander2_utils.c...
#include "miniheader.h"

void	init_dasvidaniya_norminette(int *len, int *i)
{
	*len = 0;
	*i = 0;
}

void	copy_exit_status(char *result, int *j, char *exit_status_str)
{
	int	k;

	k = 0;
	while (exit_status_str[k])
	{
		result[*j] = exit_status_str[k];
		k++;
		(*j)++;
	}
}

--- End of /home/tobiasz/TODAY/expander2_utils.c ---

Processing /home/tobiasz/TODAY/expander3.c...
#include "miniheader.h"

int	build_expanded_string(const char *token, t_var_expand *v_exp,
				t_shell_state *shell_state)
{
	const char	*cursor;
	const char	*dollar_sign;
	char		*dest_ptr;
	int			status;

	cursor = token;
	dest_ptr = v_exp->result;
	dollar_sign = ft_strchr(cursor, '$');
	while (dollar_sign)
	{
		status = copy_literal_text(&dest_ptr, cursor, dollar_sign);
		if (status == -1)
			return (-1);
		cursor = dollar_sign + 1;
		if (*cursor == '\0')
			break ;
		status = expand_variable(&dest_ptr, &cursor, shell_state);
		if (status == -1)
			return (-1);
		dollar_sign = ft_strchr(cursor, '$');
	}
	ft_strcpy(dest_ptr, cursor);
	return (0);
}

int	handle_variable_expansion(const char **cursor, int length,
				t_var_expand *v_exp, t_shell_state *shell_state)
{
	int	var_value_len;

	var_value_len = get_variable_value_length(*cursor, length, shell_state);
	if (var_value_len == -1)
		return (-1);
	v_exp->total_length += var_value_len;
	*cursor += length;
	return (0);
}

int	calculate_total_length(const char *token, t_var_expand *v_exp,
				t_shell_state *shell_state)
{
	const char	*cursor;
	const char	*dollar_sign;
	int			length;

	cursor = token;
	v_exp->total_length = 0;
	dollar_sign = ft_strchr(cursor, '$');
	while (dollar_sign != NULL)
	{
		length = dollar_sign - cursor;
		v_exp->total_length += length;
		cursor = dollar_sign + 1;
		dollar_sign = ft_strchr(cursor, '$');
		length = get_variable_name_length(cursor);
		if (length > 0)
		{
			if (handle_variable_expansion(&cursor, length,
					v_exp, shell_state) == -1)
				return (-1);
		}
		else
			v_exp->total_length++;
	}
	v_exp->total_length += ft_strlen(cursor);
	return (0);
}

char	*expand_variable_in_token(const char *token, t_var_expand *v_exp,
					t_shell_state *shell_state)
{
	int	status;

	if (!token || !v_exp || !shell_state)
		return (NULL);
	status = calculate_total_length(token, v_exp, shell_state);
	if (status == -1)
		return (NULL);
	v_exp->result = malloc(v_exp->total_length + 1);
	if (!v_exp->result)
		return (NULL);
	status = build_expanded_string(token, v_exp, shell_state);
	if (status == -1)
	{
		free(v_exp->result);
		return (NULL);
	}
	return (v_exp->result);
}

--- End of /home/tobiasz/TODAY/expander3.c ---

Processing /home/tobiasz/TODAY/expander4.c...
#include "miniheader.h"

t_env_var	*find_local_env_var(t_env_var *env_list, const char *name)
{
	t_env_var	*current;

	current = env_list;
	while (current)
	{
		if (ft_strcmp(current->name, name) == 0)
			return (current);
		current = current->next;
	}
	return (NULL);
}

int	handle_variable_value(char **dest_ptr, const char **cursor,
				t_shell_state *shell_state, int var_len)
{
	char		*extracted_var_name;
	char		*var_value;
	t_env_var	*local_var;
	int			value_len;

	extracted_var_name = ft_strndup(*cursor, var_len);
	if (!extracted_var_name)
		return (-1);
	local_var = find_env_var(shell_state->env_list, extracted_var_name);
	if (local_var)
		var_value = local_var->value;
	else
		var_value = "";
	free(extracted_var_name);
	if (var_value)
	{
		value_len = ft_strlen(var_value);
		ft_memcpy(*dest_ptr, var_value, value_len);
		*dest_ptr += value_len;
	}
	*cursor += var_len;
	return (0);
}

int	expand_variable(char **dest_ptr, const char **cursor,
				t_shell_state *shell_state)
{
	int	var_len;

	var_len = get_variable_name_length(*cursor);
	if (var_len > 0)
	{
		if (handle_variable_value(dest_ptr, cursor, shell_state, var_len) == -1)
			return (-1);
	}
	else
	{
		add_dollar_char(dest_ptr);
	}
	return (0);
}

// int	expand_variable(char **dest_ptr, const char **cursor,
// 			t_shell_state *shell_state)
// {
// 	int			var_len;
// 	char		*extracted_var_name;
// 	char		*var_value;
// 	int			value_len;
// 	t_env_var	*local_var;

// 	var_len = get_variable_name_length(*cursor);
// 	if (var_len > 0)
// 	{
// 		extracted_var_name = ft_strndup(*cursor, var_len);
// 		if (!extracted_var_name)
// 			return (-1);
// 		local_var = find_env_var(shell_state->env_list, extracted_var_name);
// 		if (local_var)
// 			var_value = local_var->value;
// 		else
// 			var_value = "";
// 		free(extracted_var_name);
// 		if (var_value)
// 		{
// 			value_len = ft_strlen(var_value);
// 			ft_memcpy(*dest_ptr, var_value, value_len);
// 			*dest_ptr += value_len;
// 		}
// 		*cursor += var_len;
// 	}
// 	else
// 		add_dollar_char(dest_ptr);
// 	return (0);
// }

--- End of /home/tobiasz/TODAY/expander4.c ---

Processing /home/tobiasz/TODAY/expander5_utils.c...
#include "miniheader.h"

void	add_dollar_char(char **dest_ptr)
{
	**dest_ptr = '$';
	(*dest_ptr)++;
}

int	copy_literal_text(char **dest_ptr, const char *start, const char *end)
{
	int	len;

	len = end - start;
	ft_memcpy(*dest_ptr, start, len);
	*dest_ptr += len;
	return (0);
}

int	get_variable_name_length(const char *str)
{
	int	var_len;

	var_len = 0;
	while (isalnum(str[var_len]) || str[var_len] == '_')
		var_len++;
	return (var_len);
}

int	get_variable_value_length(const char *var_name, int var_len,
					t_shell_state *shell_state)
{
	char		*extracted_var_name;
	char		*var_value;
	int			value_len;
	t_env_var	*local_var;

	extracted_var_name = ft_strndup(var_name, var_len);
	if (!extracted_var_name)
		return (-1);
	local_var = find_env_var(shell_state->env_list, extracted_var_name);
	if (local_var)
		var_value = local_var->value;
	else
		var_value = "";
	free(extracted_var_name);
	if (var_value)
	{
		value_len = ft_strlen(var_value);
		return (value_len);
	}
	return (0);
}

--- End of /home/tobiasz/TODAY/expander5_utils.c ---

Processing /home/tobiasz/TODAY/free.c...
#include "miniheader.h"

void	free_args_array(char **args_array)
{
	int	i;

	if (!args_array)
		return ;
	i = 0;
	while (args_array[i])
	{
		free(args_array[i]);
		i++;
	}
	free(args_array);
}

void	free_tokens(t_token_node *tokens)
{
	t_token_node	*temp;

	while (tokens)
	{
		temp = tokens;
		tokens = tokens->next;
		if (temp->token)
			free(temp->token);
		free(temp);
	}
}

void	free_token_list(t_token_node *tokens)
{
	t_token_node	*current;
	t_token_node	*next;

	current = tokens;
	while (current != NULL)
	{
		next = current->next;
		if (current->token != NULL)
			free(current->token);
		free(current);
		current = next;
	}
}

--- End of /home/tobiasz/TODAY/free.c ---

Processing /home/tobiasz/TODAY/free2.c...
#include "miniheader.h"

void	free_command_and_args(t_command *command)
{
	t_list_args	*current_arg;
	t_list_args	*next_arg;

	if (command->cmd_name)
	{
		free(command->cmd_name);
		command->cmd_name = NULL;
	}
	current_arg = command->args_list;
	while (current_arg)
	{
		next_arg = current_arg->next;
		if (current_arg->arg)
		{
			free(current_arg->arg);
			current_arg->arg = NULL;
		}
		free(current_arg);
		current_arg = next_arg;
	}
	free(command);
}

void	free_command_redirections(t_redirection *redirections)
{
	t_redirection	*current_redirection;
	t_redirection	*next_redirection;

	current_redirection = redirections;
	while (current_redirection)
	{
		next_redirection = current_redirection->next;
		if (current_redirection->filename)
			free(current_redirection->filename);
		if (current_redirection->heredoc_filename)
		{
			unlink(current_redirection->heredoc_filename);
			free(current_redirection->heredoc_filename);
			current_redirection->heredoc_filename = NULL;
		}
		free(current_redirection);
		current_redirection = next_redirection;
	}
}

void	free_command(t_command *command)
{
	if (command)
	{
		free_command_redirections(command->redirections);
		free_command_and_args(command);
	}
}

void	free_command_list(t_command *command_list)
{
	t_command	*current;
	t_command	*next;

	current = command_list;
	while (current)
	{
		next = current->next;
		free_command(current);
		current = next;
	}
}

void	free_redirections(t_redirection *redirection)
{
	t_redirection	*current;
	t_redirection	*next;

	current = redirection;
	while (current)
	{
		next = current->next;
		if (current->filename)
			free(current->filename);
		free(current);
		current = next;
	}
}

--- End of /home/tobiasz/TODAY/free2.c ---

Processing /home/tobiasz/TODAY/get_cmd_path.c...
#include "miniheader.h"

char	*check_absolute_or_relative(const char *cmd_name)
{
	if (cmd_name[0] == '/' || cmd_name[0] == '.')
	{
		if (access(cmd_name, X_OK) == 0)
			return (ft_strdup(cmd_name));
		return (NULL);
	}
	return (NULL);
}

char	**get_path_directories(t_shell_state *shell_state)
{
	char		*path_env;
	t_env_var	*path_var;
	char		**paths;

	path_var = find_env_var(shell_state->env_list, "PATH");
	if (path_var)
		path_env = path_var->value;
	else
		path_env = NULL;
	if (!path_env)
		return (NULL);
	paths = ft_split(path_env, ':');
	if (!paths)
		return (NULL);
	return (paths);
}

char	*build_full_path(const char *path, const char *cmd_name)
{
	size_t	path_len;
	size_t	cmd_len;
	char	*full_path;

	path_len = ft_strlen(path);
	cmd_len = ft_strlen(cmd_name);
	full_path = malloc(path_len + cmd_len + 2);
	if (!full_path)
		return (NULL);
	ft_strcpy(full_path, path);
	ft_strcat(full_path, "/");
	ft_strcat(full_path, cmd_name);
	return (full_path);
}

char	*search_in_paths(const char *cmd_name, char **paths)
{
	struct stat	path_stat;
	char	*full_path;
	int		i;

	i = 0;
	while (paths[i] != NULL)
	{
		full_path = build_full_path(paths[i], cmd_name);
		if (!full_path)
			return (NULL);
		stat(full_path, &path_stat);
		if (access(full_path, X_OK) == 0 && S_ISREG(path_stat.st_mode))
			return (full_path);
		free(full_path);
		i++;
	}
	return (NULL);
}

char	*get_command_path(const char *cmd_name, t_shell_state *shell_state)
{
	char	*command_path;
	char	**paths;

	command_path = check_absolute_or_relative(cmd_name);
	if (command_path)
		return (command_path);
	paths = get_path_directories(shell_state);
	if (!paths)
		return (NULL);
	command_path = search_in_paths(cmd_name, paths);
	free_args_array(paths);
	return (command_path);
}

--- End of /home/tobiasz/TODAY/get_cmd_path.c ---

Processing /home/tobiasz/TODAY/lexer.c...
#include "miniheader.h"

void	lexer_var_init(t_token_node **head, t_token_node **tail,
			t_token_state *state, t_token_list *token_list)
{
	*head = NULL;
	*tail = NULL;
	state->token_str = NULL;
	state->single_quote = false;
	state->double_quote = false;
	token_list->head = head;
	token_list->tail = tail;
	token_list->state = state;
	token_list->i = 0;
	token_list->result = 0;
}

t_token_node	*lexer(char *input, t_shell_state *shell_state)
{
	t_token_node	*head;
	t_token_node	*tail;
	t_token_state	state;
	t_token_list	token_list;

	lexer_var_init(&head, &tail, &state, &token_list);
	while (input[token_list.i])
	{
		token_list.i = skip_spaces(input, token_list.i);
		token_list.result = prcs_nxt_tkn(input, &token_list, shell_state);
		if (token_list.result == -1)
		{
			if (head)
				free_tokens(head);
			return (NULL);
		}
		token_list.i = token_list.result;
		if (input[token_list.i] == ' ')
			token_list.i++;
	}
	return (head);
}

--- End of /home/tobiasz/TODAY/lexer.c ---

Processing /home/tobiasz/TODAY/lexer2_process.c...
#include "miniheader.h"

int	process_normal_token(char *input, t_token_list *token_list)
{
	int		start;
	char	*temp_token;
	char	*new_str;

	start = token_list->i;
	while (input[token_list->i] && input[token_list->i] != ' '
		&& !is_operator(input[token_list->i])
		&& input[token_list->i] != '\''
		&& input[token_list->i] != '"')
		token_list->i++;
	temp_token = ft_strndup(input + start, token_list->i - start);
	if (!temp_token)
		return (-1);
	new_str = ft_strjoin(token_list->state->token_str, temp_token);
	free(token_list->state->token_str);
	free(temp_token);
	if (!new_str)
		return (-1);
	token_list->state->token_str = new_str;
	return (token_list->i);
}

int	handle_expansions_and_normal_tokens(char *input, t_token_list *token_list,
					t_shell_state *shell_state)
{
	t_var_expand	v_exp;
	char			*expanded_token;
	t_token_node	*expanded_node;

	expanded_token = NULL;
	(void)shell_state;
	if (input[token_list->i] == '$')
	{
		expanded_token = expand_variable_in_token(input, &v_exp, shell_state);
		if (expanded_token)
		{
			expanded_node = create_token_node(expanded_token,
					token_list->state->single_quote,
					token_list->state->double_quote);
			free(expanded_token);
			if (!expanded_node)
				return (-1);
			add_token_node(token_list, expanded_node);
		}
		if (v_exp.var_value == NULL)
			v_exp.var_value = "";
		token_list->i += ft_strlen(v_exp.var_value);
		return (0);
	}
	return (process_normal_token(input, token_list));
}

int	prcs_tokn(char *input, t_token_list *token_list, t_shell_state *shell_state)
{
	char	quote;

	if (is_operator(input[token_list->i]))
		return (process_special_token(input, token_list, shell_state));
	else if (input[token_list->i] == '\'' || input[token_list->i] == '"')
	{
		quote = input[token_list->i];
		return (process_quoted_token(input, quote, token_list, shell_state));
	}
	else
		return (handle_expansions_and_normal_tokens(input,
				token_list, shell_state));
}

int	prcs_nxt_tkn(char *input, t_token_list *token_list,
			t_shell_state *shell_state)
{
	if (is_operator(input[token_list->i]))
	{
		// if (token_list->state->token_str == NULL
		// 	&& !*(token_list->head))
		// {
		// 	if (input[token_list->i] == '>')
		// 	{
		// 		add_token_to_list(token_list, "/bin/true");
		// 	}
		// }
		return (prcs_tokn(input, token_list, shell_state));
	}
	while (input[token_list->i] && input[token_list->i] != ' '
		&& !is_operator(input[token_list->i]))
	{
		token_list->i = prcs_tokn(input, token_list, shell_state);
		if (token_list->i == -1)
			return (handle_token_error(token_list->state));
	}
	if (token_list->state->token_str)
		create_real_token(token_list);
	return (token_list->i);
}

--- End of /home/tobiasz/TODAY/lexer2_process.c ---

Processing /home/tobiasz/TODAY/lexer3_special_process.c...
#include "miniheader.h"

int	handle_expanded_token(char **temp_token, char quote,
				t_shell_state *shell_state)
{
	char	*expanded_token;

	if (quote == '"')
	{
		expanded_token = expand_var_in_string(*temp_token, shell_state);
		free(*temp_token);
		if (!expanded_token)
			return (-1);
		*temp_token = expanded_token;
	}
	return (0);
}

int	process_quoted_token(char *input, char quote,
			t_token_list *token_list, t_shell_state *shell_state)
{
	int		start;
	int		end;
	char	*temp_token;
	int		result;

	token_list->i++;
	start = token_list->i;
	end = find_closing_quote(input, token_list->i, quote);
	if (end == -1)
	{
		handle_unclosed_quote_error(token_list->state);
		return (-1);
	}
	temp_token = ft_strndup(input + start, end - start);
	if (!temp_token)
		return (-1);
	if (handle_expanded_token(&temp_token, quote, shell_state) == -1)
		return (-1);
	result = append_to_temp_token_str(token_list->state, temp_token);
	free(temp_token);
	if (result == -1)
		return (-1);
	set_quote_flag(token_list->state, quote);
	token_list->i = end + 1;
	return (token_list->i);
}

int	process_special_token(char *input, t_token_list *token_list,
				t_shell_state *shell_state)
{
	char	current_char;

	current_char = input[token_list->i];
	if (current_char == '$')
		return (handle_dollar_token(input, token_list, shell_state));
	else
		return (handle_operator_token(input, token_list));
}

// int	process_quoted_token(char *input, char quote,
// 			t_token_list *token_list, t_shell_state *shell_state)
// {
// 	int		start;
// 	int		end;
// 	char	*temp_token;
// 	char	*expanded_token;
// 	int		result;

// 	token_list->i++;
// 	start = token_list->i;
// 	end = find_closing_quote(input, token_list->i, quote);
// 	if (end == -1)
// 	{
// 		handle_unclosed_quote_error(token_list->state);
// 		return (-1);
// 	}
// 	temp_token = ft_strndup(input + start, end - start);
// 	if (!temp_token)
// 		return (-1);
// 	if (quote == '"')
// 	{
// 		expanded_token = expand_var_in_string(temp_token, shell_state);
// 		free(temp_token);
// 		if (!expanded_token)
// 			return (-1);
// 		temp_token = expanded_token;
// 	}
// 	result = append_to_temp_token_str(token_list->state, temp_token);
// 	free(temp_token);
// 	if (result == -1)
// 		return (-1);
// 	set_quote_flag(token_list->state, quote);
// 	token_list->i = end + 1;
// 	return (token_list->i);
// }
--- End of /home/tobiasz/TODAY/lexer3_special_process.c ---

Processing /home/tobiasz/TODAY/lexer4_handle_operator.c...
#include "miniheader.h"

int	handle_double_operator(char *input, t_token_list *token_list)
{
	char	*operator_str;

	operator_str = ft_strndup(input + token_list->i, 2);
	if (!operator_str)
		return (-1);
	if (create_operator_node(operator_str, 2, token_list) == -1)
	{
		free(operator_str);
		return (-1);
	}
	free(operator_str);
	return (0);
}

int	handle_single_operator(char *input, t_token_list *token_list)
{
	char	*operator_str;

	operator_str = ft_strndup(input + token_list->i, 1);
	if (!operator_str)
		return (-1);
	if (create_operator_node(operator_str, 1, token_list) == -1)
	{
		free(operator_str);
		return (-1);
	}
	free(operator_str);
	return (0);
}

int	handle_operator_token(char *input, t_token_list *token_list)
{
	char	current_char;
	char	next_char;

	current_char = input[token_list->i];
	next_char = input[token_list->i + 1];
	if ((current_char == '>' && next_char == '>')
		|| (current_char == '<' && next_char == '<'))
	{
		if (handle_double_operator(input, token_list) == -1)
			return (-1);
	}
	else
	{
		if (handle_single_operator(input, token_list) == -1)
			return (-1);
	}
	return (token_list->i);
}

--- End of /home/tobiasz/TODAY/lexer4_handle_operator.c ---

Processing /home/tobiasz/TODAY/lexer4_handle_token.c...
#include "miniheader.h"

int	create_and_add_variable_token(char *input, int start,
				t_token_list *token_list,
				bool single_quote,
				bool double_quote)
{
	int				var_length;
	char			*var_name;
	t_token_node	*var_node;

	var_length = token_list->i - start;
	var_name = ft_strndup(input + start, var_length);
	if (!var_name)
		return (-1);
	var_node = create_token_node(var_name, single_quote, double_quote);
	free(var_name);
	if (!var_node)
		return (-1);
	var_node->type = TOKEN_VARIABLE;
	add_token_node(token_list, var_node);
	return (0);
}

int	handle_variable_token(char *input, t_token_list *token_list)
{
	int	start;

	start = token_list->i;
	while (input[token_list->i] && (isalnum(input[token_list->i])
			|| input[token_list->i] == '_'))
		token_list->i++;
	if (create_and_add_variable_token(input, start, token_list,
			token_list->state->single_quote,
			token_list->state->double_quote) < 0)
		return (-1);
	return (token_list->i);
}

int	handle_exit_status_token(t_token_list *token_list,
				t_shell_state *shell_state)
{
	char			*status_str;
	t_token_node	*status_node;

	status_str = ft_itoa(shell_state->last_exit_status);
	if (!status_str)
		return (-1);
	status_node = create_token_node(status_str,
			token_list->state->single_quote,
			token_list->state->double_quote);
	free(status_str);
	if (!status_node)
		return (-1);
	status_node->type = TOKEN_WORD;
	add_token_node(token_list, status_node);
	token_list->i += 2;
	return (token_list->i);
}

int	handle_dollar_token(char *input, t_token_list *token_list,
			t_shell_state *shell_state)
{
	char			*dollar_str;
	t_token_node	*dollar_node;

	if (input[token_list->i + 1] == '?')
		return (handle_exit_status_token(token_list, shell_state));
	dollar_str = ft_strndup("$", 1);
	if (!dollar_str)
		return (-1);
	dollar_node = create_token_node(dollar_str,
			token_list->state->single_quote, token_list->state->double_quote);
	free(dollar_str);
	if (!dollar_node)
		return (-1);
	dollar_node->type = TOKEN_DOLLAR;
	add_token_node(token_list, dollar_node);
	token_list->i++;
	if (input[token_list->i] && (isalnum(input[token_list->i])
			|| input[token_list->i] == '_'))
		return (handle_variable_token(input, token_list));
	return (token_list->i);
}

--- End of /home/tobiasz/TODAY/lexer4_handle_token.c ---

Processing /home/tobiasz/TODAY/lexer5_handle_token_utils.c...
#include "miniheader.h"

int	create_operator_node(char *operator_str, int increment,
				t_token_list *token_list)
{
	t_token_node	*op_node;

	op_node = create_token_node(operator_str,
			token_list->state->single_quote,
			token_list->state->double_quote);
	if (!op_node)
		return (-1);
	add_token_node(token_list, op_node);
	token_list->i += increment;
	return (token_list->i);
}

--- End of /home/tobiasz/TODAY/lexer5_handle_token_utils.c ---

Processing /home/tobiasz/TODAY/lexer6_create_token.c...
#include "miniheader.h"

t_token_node	*create_token_node(char *token_str, bool single_quote,
					bool double_quote)
{
	t_token_node	*token_node;

	token_node = malloc(sizeof(t_token_node));
	if (!token_node)
		return (NULL);
	token_node->token = ft_strdup(token_str);
	if (!token_node->token)
	{
		free(token_node);
		return (NULL);
	}
	token_node->single_quote = single_quote;
	token_node->double_quote = double_quote;
	token_node->type = determine_token_type(token_node);
	token_node->next = NULL;
	return (token_node);
}

void	create_real_token(t_token_list *token_list)
{
	t_token_node	*new_node;

	new_node = create_token_node(token_list->state->token_str,
			token_list->state->single_quote,
			token_list->state->double_quote);
	if (new_node)
	{
		add_token_node(token_list, new_node);
	}
	free(token_list->state->token_str);
	token_list->state->token_str = NULL;
	token_list->state->single_quote = false;
	token_list->state->double_quote = false;
}

--- End of /home/tobiasz/TODAY/lexer6_create_token.c ---

Processing /home/tobiasz/TODAY/lexer7_node_utils.c...
#include "miniheader.h"

void	add_token_to_list(t_token_list *token_list, char *token_str)
{
	t_token_node	*new_node;

	new_node = create_token_node(token_str,
			token_list->state->single_quote,
			token_list->state->double_quote);
	if (new_node)
		add_token_node(token_list, new_node);
}

void	add_token_node(t_token_list *token_list, t_token_node *new_node)
{
	if (!*(token_list->head))
		*(token_list->head) = new_node;
	else
		(*(token_list->tail))->next = new_node;
	*(token_list->tail) = new_node;
}

int	append_to_temp_token_str(t_token_state *state, char *temp_token)
{
	char	*new_str;

	new_str = ft_strjoin(state->token_str, temp_token);
	free(state->token_str);
	if (!new_str)
		return (-1);
	state->token_str = new_str;
	return (0);
}

--- End of /home/tobiasz/TODAY/lexer7_node_utils.c ---

Processing /home/tobiasz/TODAY/lexer8_gen_utils.c...
#include "miniheader.h"

int	is_operator(char c)
{
	return (c == '|' || c == '<' || c == '>' || c == '$');
}

static int	get_num_len(int n)
{
	int	len;

	len = 0;
	if (n <= 0)
		len = 1;
	while (n)
	{
		len++;
		n /= 10;
	}
	return (len);
}

char	*ft_itoa(int n)
{
	char	*result;
	long	nbr;
	int		len;

	nbr = n;
	len = get_num_len(n);
	result = (char *)malloc(sizeof(char) * (len + 1));
	if (!result)
		return (NULL);
	result[len] = '\0';
	if (nbr == 0)
		result[0] = '0';
	if (nbr < 0)
	{
		result[0] = '-';
		nbr = -nbr;
	}
	while (nbr)
	{
		result[--len] = nbr % 10 + '0';
		nbr /= 10;
	}
	return (result);
}

--- End of /home/tobiasz/TODAY/lexer8_gen_utils.c ---

Processing /home/tobiasz/TODAY/m_main.c...
#include "miniheader.h"

void	init_env_list(t_shell_state *shell_state)
{
	int				i;
	char			*env_var;
	t_env_var		*new_var;
	char			*equal_sign;

	i = 0;
	while (shell_state->envp[i])
	{
		env_var = shell_state->envp[i];
		equal_sign = ft_strchr(env_var, '=');
		if (equal_sign)
		{
			new_var = malloc(sizeof(t_env_var));
			if (!new_var)
				return ;
			new_var->name = ft_strndup(env_var, equal_sign - env_var);
			new_var->value = ft_strdup(equal_sign + 1);
			new_var->next = shell_state->env_list;
			shell_state->env_list = new_var;
		}
		i++;
	}
}

void	clean_shell_state(t_shell_state *shell_state)
{
	t_env_var	*current;
	t_env_var	*next;

	current = shell_state->env_list;
	while (current)
	{
		next = current->next;
		free(current->name);
		free(current->value);
		free(current);
		current = next;
	}
}

void	shell_main_loop(t_shell_state *shell_state)
{
	char	*input;

	while (!shell_state->exit_shell)
	{
		input = readline(COLOR_BLUE"MINIPROMPT$ "COLOR_RESET);
		if (!input)
			break ;
		else if (*input == '\0')
		{
			free(input);
			continue ;
		}
		add_history(input);
		process_input(input, shell_state);
		free(input);
		restore_signals_after_command();
		if (g_received_signal != 0)
		{
			g_received_signal = 0;
		}
		if (shell_state->exit_shell)
			break ;
	}
}

void	shell_loop(char **envp)
{
	char			*input;
	t_shell_state	shell_state;

	(void)input;
	shell_state.last_exit_status = 0;
	shell_state.env_list = NULL;
	shell_state.envp = envp;
	shell_state.exit_shell = false;
	shell_state.exit_code = 0;
	init_env_list(&shell_state);
	shell_main_loop(&shell_state);
	rl_clear_history();
	clean_shell_state(&shell_state);
	exit(shell_state.exit_code);
}

int	main(int ac, char **av, char **envp)
{
	if (ac > 1)
		return (printf("Usage: %s\t [No Additional Arguments]\n", av[0]), 1);
	init_sign();
	shell_loop(envp);
}

--- End of /home/tobiasz/TODAY/m_main.c ---

Processing /home/tobiasz/TODAY/m_minishell.c...
#include "miniheader.h"

void	execute_commands(t_command *command_list, t_shell_state *shell_state)
{
	if (!command_list)
		return ;
	if (process_all_heredocs(command_list, shell_state) != 0)
	{
		free_command_list(command_list);		
		return ;
	}
	if (command_list->next)
		execute_pipeline(command_list, shell_state);
	else
		execute_single_command(command_list, command_list, shell_state);
}

void	process_input(char *input, t_shell_state *shell_state)
{
	t_token_node	*tokens;
	t_command		*command_list;

	tokens = NULL;
	command_list = NULL;
	if (is_only_white_spaces(input))
		return ;
	tokens = lexer(input, shell_state);
	if (!tokens)
	{
		write(STDERR_FILENO, "Error tokenizing input\n", 23);
		return ;
	}
	command_list = parse_tokens(tokens, shell_state);
	free_token_list(tokens);
	if (!command_list)
	{
		write(STDERR_FILENO, "Error parsing tokens\n", 21);
		return ;
	}
	execute_commands(command_list, shell_state);
	free_command_list(command_list);
}

--- End of /home/tobiasz/TODAY/m_minishell.c ---

Processing /home/tobiasz/TODAY/parser.c...
#include "miniheader.h"

bool	set_command_name(t_parser_state *state, t_command *command)
{
	if (state->current_token->type == TOKEN_WORD)
	{
		command->cmd_name = ft_strdup(state->current_token->token);
		if (!command->cmd_name)
		{
			init_vars_for_cmdname_error(state, command);
			return (false);
		}
		state->current_token = state->current_token->next;
	}
	else
	{
		command->cmd_name = ft_strdup("/bin/true");
		if (!command->cmd_name)
		{
			init_vars_for_cmdname_error(state, command);
			return (false);
		}
	}
	return (true);
}

t_command	*parse_command(t_parser_state *state,
			t_shell_state *shell_state)
{
	t_command	*command;

	command = malloc(sizeof(t_command));
	if (!command)
		return (init_vars_for_not_cmd(state), NULL);
	ft_memset(command, 0, sizeof(t_command));
	init_vars_for_parsing_command(command);
	if (state->current_token && (state->current_token->type == TOKEN_WORD
			|| is_redirection_token(state->current_token->type)))
	{
		if (!set_command_name(state, command))
			return (NULL);
	}
	else
		return (init_vars_for_expctd_cmdname(state, command), NULL);
	if (!add_argument(command, ft_strdup(command->cmd_name), false, false))
		return (init_vars_for_error_adding_arg(state, command), NULL);
	if (!parse_arguments_and_redirection(state, command, shell_state))
		return (free_command(command), NULL);
	return (command);
}

t_command	*parse_tokens(t_token_node *tokens, t_shell_state *shell_state)
{
	t_parser_state	state;
	t_command		*cmd_list;
	t_command		*last_command;
	t_command		*command;

	cmd_list = NULL;
	last_command = NULL;
	init_var_for_parsing_tokens(tokens, &state, &cmd_list, &last_command);
	while (state.current_token && !state.flg_error)
	{
		command = parse_command(&state, shell_state);
		if (state.flg_error)
		{
			call_error_and_free(&state, &cmd_list);
			return (NULL);
		}
		if (!cmd_list)
			cmd_list = command;
		else
			last_command->next = command;
		last_command = command;
		if (state.current_token && state.current_token->type == TOKEN_PIPE)
			state.current_token = state.current_token->next;
	}
	return (cmd_list);
}

--- End of /home/tobiasz/TODAY/parser.c ---

Processing /home/tobiasz/TODAY/parser2_args_and_redir.c...
#include "miniheader.h"

int	add_argument(t_command *command, char *arg_value, bool single_quote,
				bool double_quote)
{
	t_list_args	*new_arg;
	t_list_args	*last;

	if (!arg_value)
		return (0);
	new_arg = malloc(sizeof(t_list_args));
	if (!new_arg)
	{
		free(arg_value);
		return (0);
	}
	new_arg->arg = arg_value;
	new_arg->single_quote = single_quote;
	new_arg->double_quote = double_quote;
	new_arg->next = NULL;
	if (!command->args_list)
		command->args_list = new_arg;
	else
	{
		last = command->args_list;
		while (last->next)
			last = last->next;
		last->next = new_arg;
	}
	return (1);
}

int	handle_token_word(t_parser_state *state, t_command *command,
		t_var_expand *v_exp, t_shell_state *shell_state)
{
	char	*arg_value;
	char	*expanded_value;

	arg_value = ft_strdup(state->current_token->token);
	if (!arg_value)
		return (init_var_failed_add_arg(state), 0);
	if (state->current_token->double_quote)
	{
		expanded_value = expand_variable_in_token(arg_value,
				v_exp, shell_state);
		free(arg_value);
		if (!expanded_value)
			return (init_var_failed_add_arg(state), 0);
		arg_value = expanded_value;
	}
	if (!add_argument(command, arg_value, state->current_token->single_quote,
			state->current_token->double_quote))
		return (init_var_failed_add_arg(state), 0);
	state->current_token = state->current_token->next;
	return (1);
}

int	handle_redirection_tokens(t_parser_state *state, t_command *command)
{
	if (!parse_redirection(state, command))
		return (0);
	return (1);
}

int	handle_unexpected_token(t_parser_state *state)
{
	state->flg_error = true;
	state->error_msg = "Unexpected token";
	return (0);
}

int	parse_arguments_and_redirection(t_parser_state *state, t_command *command,
					t_shell_state *shell_state)
{
	t_var_expand	v_exp;

	while (state->current_token && state->current_token->type != TOKEN_PIPE)
	{
		if (state->current_token->type == TOKEN_WORD)
		{
			if (!handle_token_word(state, command, &v_exp, shell_state))
				return (0);
		}
		else if (state->current_token->type == TOKEN_DOLLAR)
		{
			if (!handle_dollar_and_variable(state, command, shell_state))
				return (0);
		}
		else if (is_redirection_token(state->current_token->type))
		{
			if (!handle_redirection_tokens(state, command))
				return (0);
		}
		else
			return (handle_unexpected_token(state));
	}
	return (1);
}

--- End of /home/tobiasz/TODAY/parser2_args_and_redir.c ---

Processing /home/tobiasz/TODAY/parser3_args_and_redir_utils.c...
#include "miniheader.h"

int	is_redirection_token(t_token_type type)
{
	if (type == TOKEN_REDIR_IN)
		return (1);
	if (type == TOKEN_REDIR_OUT)
		return (1);
	if (type == TOKEN_REDIR_APPEND)
		return (1);
	if (type == TOKEN_HEREDOC)
		return (1);
	return (0);
}

--- End of /home/tobiasz/TODAY/parser3_args_and_redir_utils.c ---

Processing /home/tobiasz/TODAY/parser4_redir_and_dollar.c...
#include "miniheader.h"

int	handle_dollar_and_variable(t_parser_state *state,
				t_command *command, t_shell_state *shell_state)
{
	char		*var_name;
	char		*var_value;
	t_env_var	*env_var;

	state->current_token = state->current_token->next;
	if (state->current_token && state->current_token->type == TOKEN_VARIABLE)
	{
		var_name = state->current_token->token;
		env_var = find_env_var(shell_state->env_list, var_name);
		if (env_var)
			var_value = env_var->value;
		else
			var_value = "";
		if (!add_argument(command, ft_strdup(var_value), false, false))
			return (init_var_failed_add_arg(state), 0);
		command->has_dollar = true;
		state->current_token = state->current_token->next;
	}
	else
	{
		if (!add_argument(command, ft_strdup("$"), false, false))
			return (init_var_failed_add_arg(state), 0);
	}
	return (1);
}

int	add_redirection_to_command(t_redirection *redirection, t_command *command)
{
	t_redirection	*last;

	if (!command->redirections)
		command->redirections = redirection;
	else
	{
		last = command->redirections;
		while (last->next)
			last = last->next;
		last->next = redirection;
	}
	return (1);
}

t_redirection	*create_redirection(t_parser_state *state)
{
	t_redirection	*redirection;

	redirection = malloc(sizeof(t_redirection));
	if (!redirection)
		return (0);
	ft_memset(redirection, 0, sizeof(t_redirection));
	redirection->type = state->current_token->type;
	state->current_token = state->current_token->next;
	return (redirection);
}

int	parse_redirection_filename(t_parser_state *state,
			t_redirection *redirection)
{
	if (state->current_token && state->current_token->type == TOKEN_WORD)
	{
		redirection->filename = ft_strdup(state->current_token->token);
		redirection->is_quoted = state->current_token->single_quote
			|| state->current_token->double_quote;
		if (!redirection->filename)
			return (0);
		state->current_token = state->current_token->next;
		return (1);
	}
	else
		return (0);
}

int	parse_redirection(t_parser_state *state, t_command *command)
{
	t_redirection	*redirection;

	redirection = create_redirection(state);
	if (!redirection)
		return (0);
	if (!parse_redirection_filename(state, redirection))
	{
		free(redirection);
		return (0);
	}
	return (add_redirection_to_command(redirection, command));
}

--- End of /home/tobiasz/TODAY/parser4_redir_and_dollar.c ---

Processing /home/tobiasz/TODAY/parser5_arg_list_to_array.c...
#include "miniheader.h"

int	count_arguments(t_list_args *args_list)
{
	int	count;

	count = 0;
	while (args_list)
	{
		count++;
		args_list = args_list->next;
	}
	return (count);
}

int	check_and_free_memory(char **args_array, bool *args_quote_flags, int count)
{
	if (!args_array || (count > 0 && !args_quote_flags))
	{
		free(args_array);
		if (count > 0)
			free(args_quote_flags);
		return (0);
	}
	return (1);
}

bool	populate_args_arrays(t_list_args *args_list,
				char **args_array, bool *args_quote_flags)
{
	t_list_args	*arg;
	int			i;

	arg = args_list;
	i = 0;
	while (arg)
	{
		args_array[i] = ft_strdup(arg->arg);
		if (!args_array[i])
		{
			while (i > 0)
			{
				i--;
				free(args_array[i]);
			}
			return (false);
		}
		args_quote_flags[i] = arg->single_quote || arg->double_quote;
		arg = arg->next;
		i++;
	}
	return (true);
}

char	**convert_arglist_for_exc(t_command *command,
				bool **args_quote_flags_ptr)
{
	char		**args_array;
	bool		*args_quote_flags;
	int			count;

	count = count_arguments(command->args_list);
	args_array = malloc(sizeof(char *) * (count + 1));
	if (count > 0)
		args_quote_flags = malloc(sizeof(bool) * count);
	else
		args_quote_flags = NULL;
	if (!check_and_free_memory(args_array, args_quote_flags, count))
		return (NULL);
	if (!populate_args_arrays(command->args_list,
			args_array, args_quote_flags))
	{
		free(args_array);
		free(args_quote_flags);
		return (NULL);
	}
	args_array[count] = NULL;
	*args_quote_flags_ptr = args_quote_flags;
	return (args_array);
}

--- End of /home/tobiasz/TODAY/parser5_arg_list_to_array.c ---

Processing /home/tobiasz/TODAY/signals.c...
#include "miniheader.h"

volatile sig_atomic_t	g_received_signal = 0;

void	handle_sigint(int sig)
{
	(void)sig;
	g_received_signal = sig;
	write(STDOUT_FILENO, "\n", 1);
	rl_on_new_line();
	rl_replace_line("", 0);
	rl_redisplay();
}

void	handle_sigquit(int sig)
{
	(void)sig;
}

void	handle_sigpipe(int sig)
{
	(void)sig;
    // Puoi semplicemente ignorare SIGPIPE
}

void init_sign(void)
{
    struct sigaction sa_int;
    struct sigaction sa_quit;
    struct sigaction sa_pipe;

    sa_int.sa_handler = handle_sigint;
    sigemptyset(&sa_int.sa_mask);
    sa_int.sa_flags = 0;
    sigaction(SIGINT, &sa_int, NULL);

    sa_quit.sa_handler = handle_sigquit;
    sigemptyset(&sa_quit.sa_mask);
    sa_quit.sa_flags = 0;
    sigaction(SIGQUIT, &sa_quit, NULL);

    // Ignore SIGPIPE in the parent process
    sa_pipe.sa_handler = SIG_IGN;
    sigemptyset(&sa_pipe.sa_mask);
    sa_pipe.sa_flags = 0;
    sigaction(SIGPIPE, &sa_pipe, NULL);
}


--- End of /home/tobiasz/TODAY/signals.c ---

Processing /home/tobiasz/TODAY/token.c...
#include "miniheader.h"

int	find_closing_quote(char *input, int i, char quote)
{
	while (input[i] && input[i] != quote)
		i++;
	if (!input[i])
		return (-1);
	return (i);
}

void	handle_unclosed_quote_error(t_token_state *state)
{
	printf("Error: Unclosed quote detected\n");
	if (state->token_str)
	{
		free(state->token_str);
		state->token_str = NULL;
	}
}

void	set_quote_flag(t_token_state *state, char quote)
{
	if (quote == '\'')
		state->single_quote = true;
	else if (quote == '"')
		state->double_quote = true;
}

int	handle_token_error(t_token_state *state)
{
	if (state->token_str)
	{
		free(state->token_str);
		state->token_str = NULL;
	}
	return (-1);
}

t_token_type	determine_token_type(t_token_node *token_node)
{
	char	*token_str;

	if (token_node->single_quote || token_node->double_quote)
	{
		return (TOKEN_WORD);
	}
	token_str = token_node->token;
	if (strcmp(token_str, "|") == 0)
		return (TOKEN_PIPE);
	else if (strcmp(token_str, ">>") == 0)
		return (TOKEN_REDIR_APPEND);
	else if (strcmp(token_str, "<<") == 0)
		return (TOKEN_HEREDOC);
	else if (strcmp(token_str, "<") == 0)
		return (TOKEN_REDIR_IN);
	else if (strcmp(token_str, ">") == 0)
		return (TOKEN_REDIR_OUT);
	else if (strcmp(token_str, "$") == 0)
		return (TOKEN_DOLLAR);
	else
		return (TOKEN_WORD);
}

--- End of /home/tobiasz/TODAY/token.c ---

